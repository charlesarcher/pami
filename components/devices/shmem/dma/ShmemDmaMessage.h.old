/* ---------------------------------------------------------------- */
/* (C)Copyright IBM Corp.  2007, 2008                               */
/* IBM CPL License                                                  */
/* ---------------------------------------------------------------- */
/*                                                                  */
/* end_generated_IBM_copyright_prolog                               */
/**
 * \file devices/prod/cdi/shmem/dma/ShmemDmaMessage.h
 * \brief ???
 */

#ifndef __dcmf_cdi_shmem_dma_message_h__
#define __dcmf_cdi_shmem_dma_message_h__

#include "SysDep.h"
#include "../../DmaMessage.h"
#include "../ShmemPacketMessage.h"

namespace DCMF
{
  namespace CDI
  {
    typedef struct dma_chunk_info_t
    {
      void * src_addr;
      void * dst_addr;
      size_t bytes;
    } dma_chunk_info_t;

    template <class T_Memregion, class T_Atomic>
    class ShmemDmaMessage : public ShmemPacketMessage, public DMA::Message< ShmemDmaMessage<T_Memregion, T_Atomic> >
    {
      public:
        inline ShmemDmaMessage (DCMF_Callback_t       & cb,
                                ShmemFifoPacketHeader * model,
                                size_t                  peer,
                                size_t                  src_rank,
                                T_Memregion           * src_mr,
                                DMA::offset_vec_t     * src_vec,
                                unsigned                src_vec_count,
                                size_t                  dst_rank,
                                T_Memregion           * dst_mr,
                                DMA::offset_vec_t     * dst_vec,
                                unsigned                dst_vec_count,
                                DCMF_Callback           hook_cb,
                                void                  * device,
                                DCMF_Result           & status) :
            ShmemPacketMessage (cb, model, peer, (struct iovec *)NULL, 0, true, status),
            _src_rank (src_rank),
            _src_mr (src_mr),
            _src_vec (src_vec),
            _src_vec_count (src_vec_count),
            _dst_rank (dst_rank),
            _dst_mr (dst_mr),
            _dst_vec (dst_vec),
            _dst_vec_count (dst_vec_count),
            _npackets (0)
        {
          DCMF_assert_debug(_src_vec_count == 1);
          _isGet = (model->getOriginRank() == src_rank);

          // Initialize the iterator state variables.
          _src_index_bytes_remaining = _src_vec[0].len;
          _dst_index_bytes_remaining = _dst_vec[0].len;
          _src_index = 0;
          _dst_index = 0;

          _cb.function   = hook_cb;
          _cb.clientdata = (void *) & _cb_data[0];
          _cb_data[0]    = (void *) this;
          _cb_data[1]    = (void *) device;

          _cb_user.function   = cb.function;
          _cb_user.clientdata = cb.clientdata;

          status = DCMF_SUCCESS;
        };

        inline ~ShmemDmaMessage () {};

        inline int executeUserCallback_impl (DCMF_Error_t * error = NULL)
        {
          if (_cb_user.function)
            {
              _cb_user.function (_cb_user.clientdata, error);
            }

          return 0;
        };

        inline int getSlotReservation ()
        {
          return _slotReservation;
        }

        inline void setSlotReservation (int reservation)
        {
          _slotReservation = reservation;
        }

        virtual int advance (LinearFifo<T_Atomic> * fifo);

        /// \retval 0 Message completed
        /// \retval 1 Message not complete
        inline bool advanceWithReservation (LinearFifo<T_Atomic> * fifo)
        {
          ShmemFifoPacket * pkt;
          unsigned index;

          if (fifo->getNextInjectionBuffer (&pkt, index))
            {
              ShmemFifoPacketHeader * hdr = (ShmemFifoPacketHeader *) pkt->getHeader();

              // Copy the message's packet header into the destination packet header.
              // Eventually, this should use an optimized quad-copy function.
              memcpy((void *)hdr, (void *)_pkthdr, sizeof(ShmemFifoPacketHeader));

              dma_chunk_info_t * info = (dma_chunk_info_t *) (pkt->getData () + sizeof(DCQuad));
              unsigned max = (sizeof (ShmemFifoPacket) - sizeof (ShmemFifoPacketHeader)) / sizeof(dma_chunk_info_t);

              // Two "vectors" in a dma packet. The first is the number of "chucks"
              // to transfer, the second is the "chunk" array.
              hdr->setVectorCount (2);

              hdr->setVectorBytes (0, sizeof(unsigned));
              unsigned * num = (unsigned *) pkt->getData();

              bool advance_again = initializeDmaXferArray (info, max, num);

              // Set size of the chunk array.
              hdr->setVectorBytes (1, sizeof(dma_chunk_info_t) * (*num));

              fifo->completeInjectionBuffer (index);
              mem_barrier();

              // Increment the packet count for this message.
              _npackets ++;

              return advance_again;
            }

          return true;
        }

        inline void setPackets (unsigned n) { _npackets = n; }
        inline void incPackets (unsigned n) { _npackets += n; }
        inline unsigned getPackets ()       { return _npackets; }

        inline void setSequence (uint64_t n) { _sequence = n; }
        inline uint64_t getSequence ()       { return _sequence; }

      protected:

        virtual inline bool initializeDmaXferArray (dma_chunk_info_t * info, unsigned max, unsigned * num)
        {
          bool advance_again = false;
#if 0
          unsigned chunk = 0;
          size_t src_offset, dst_offset;

          do
            {
              advance_again = next (src_offset, dst_offset, info[chunk].bytes);

              info[chunk].src_addr = (void *)((char *)_src_mr->getBaseVirtualAddress() + src_offset);
              info[chunk].dst_addr = (void *)((char *)_dst_mr->getBaseVirtualAddress() + dst_offset);
              chunk++;
            }
          while (advance_again && (chunk < max));

          *num = chunk;
#endif
          return advance_again;
        }

        inline bool next (size_t & src_offset, size_t & dst_offset, size_t & bytes)
        {
          size_t n = MIN(_src_index_bytes_remaining, _dst_index_bytes_remaining);

          if (n > 0)
            {
              src_offset = _src_vec[_src_index].len - _src_index_bytes_remaining;
              dst_offset = _dst_vec[_dst_index].len - _dst_index_bytes_remaining;
              bytes = n;

              if (((_src_index_bytes_remaining - n) == 0) &&
                  ((_src_index + 1) == _src_vec_count))
                {
                  // The source vector offset array has been completely processed.
                  // The destination vector offset array must also have been
                  // completely processed, otherwise it is an error.
                  return false;
                }

              _src_index_bytes_remaining -= n;
              _dst_index_bytes_remaining -= n;
              return true;
            }

          // Recurse (once) to advance state to the next vector(s).
          bool rc = nextUpdate (src_offset, dst_offset, bytes);

          return rc;
        }


        bool nextUpdate (size_t & src_offset, size_t & dst_offset, size_t & bytes)
        {
          // One (or both) offset vectors have completed.
          if (_src_index_bytes_remaining == 0)
            {
              _src_index_bytes_remaining = _src_vec[++_src_index].len;
            }

          if (_dst_index_bytes_remaining == 0)
            {
              _dst_index_bytes_remaining = _dst_vec[++_dst_index].len;
            }

          // Recurse (once) to get offsets and bytes.
          return next (src_offset, dst_offset, bytes);
        }

        size_t                  _src_rank;
        T_Memregion           * _src_mr;
        DMA::offset_vec_t     * _src_vec;
        unsigned                _src_vec_count;
        size_t                  _dst_rank;
        T_Memregion           * _dst_mr;
        DMA::offset_vec_t     * _dst_vec;
        unsigned                _dst_vec_count;

        bool                    _isGet;

        // offset iterator state variables.
        size_t   _src_index_bytes_remaining;
        size_t   _dst_index_bytes_remaining;
        unsigned _src_index;
        unsigned _dst_index;

        unsigned _npackets; ///< Number of packets written to the fifo.
        uint64_t _sequence; ///< Sequence number of the last packet of the message.

        DCMF_Callback_t   _cb_user;
        void            * _cb_data[2];
    };

    ///
    /// \retval  0 Message is localy complete
    /// \retval !0 Message is incomplete and must be advanced later.
    ///
    template <class T_Memregion, class T_Atomic>
    int ShmemDmaMessage<T_Memregion, T_Atomic>::advance (LinearFifo<T_Atomic> * fifo)
    {
      if (_slotReservation == -1)
        fifo->allocateSlotReservation ();

      bool rc = advanceWithReservation (fifo);
      return rc;
    };
  };
};
#endif

//
// astyle info    http://astyle.sourceforge.net
//
// astyle options --style=gnu --indent=spaces=2 --indent-classes
// astyle options --indent-switches --indent-namespaces --break-blocks
// astyle options --pad-oper --keep-one-line-blocks --max-instatement-indent=79
//

/**
 * \file sys/xmi.h
 * \brief Common external interface for IBM's XMI message layer.
 */

#ifndef __xmi_h__
#define __xmi_h__

#include <stdlib.h>
#include <stdint.h>
#include <sys/uio.h>

#include "xmi_config.h"

#ifdef __cplusplus
extern "C"
{
#endif

  /**
   * \brief XMI result status codes.
   */
  typedef enum
  {
    XMI_SUCCESS =  0, /**< Successful execution        */
    XMI_NERROR  = -1, /**< Generic error (-1)          */
    XMI_ERROR   =  1, /**< Generic error (+1)          */
    XMI_INVAL,        /**< Invalid argument            */
    XMI_UNIMPL,       /**< Function is not implemented */
    XMI_EAGAIN,       /**< Not currently availible     */
    XMI_SHUTDOWN,     /**< Task has shutdown           */
    XMI_CHECK_ERRNO,  /**< Check the errno val         */
    XMI_OTHER,        /**< Other undefined error       */
  } xmi_result_t;

  typedef void*    xmi_client_t;  /**< ??? */
  typedef void*    xmi_context_t; /**< ??? */
  typedef void*    xmi_type_t;    /**< ??? */
  typedef uint32_t xmi_task_t;    /**< This should be generated by configure. */
  typedef uint32_t xmi_endpoint_t;/**< foo */

  /**
   * \brief Callback to handle message events
   *
   * \param[in] context   XMI communication context that invoked the callback
   * \param[in] cookie    Event callback application argument
   * \param[in] result    Asynchronous result information (was error information)
   */
  typedef void (*xmi_event_function) ( xmi_context_t   context,
                                       void          * cookie,
                                       xmi_result_t    result );

  /**
   * \brief Prototype for function used for context-queued work (post)
   *
   * Posted function will continue to run as long a return value is > 0.
   * Return value < 0 indicates -(xmi_result_t) and stops function from
   * being called. Return value of XMI_SUCCESS (0) stops function.
   *
   * \param[in] context   XMI communication context running function
   * \param[in] cookie    application argument
   * \return	(0) XMI_SUCCESS causes function to dequeue (stop running)
   *		XMI_EAGAIN causes function to remain queued and is called on next advance
   * 		(any other value) causes function to dequeue and (optionally) report error
   */
  typedef xmi_result_t (*xmi_work_function)(xmi_context_t context, void *cookie);

  typedef uintptr_t xmi_work_t[8];

  typedef struct
  {
    xmi_event_function  function;
    void               *clientdata;
  } xmi_callback_t;

/**
 * \brief Message layer operation types
 */

  typedef enum
  {
    XMI_UNDEFINED_OP = 0,
    XMI_NOOP,
    XMI_MAX,
    XMI_MIN,
    XMI_SUM,
    XMI_PROD,
    XMI_LAND,
    XMI_LOR,
    XMI_LXOR,
    XMI_BAND,
    XMI_BOR,
    XMI_BXOR,
    XMI_MAXLOC,
    XMI_MINLOC,
    XMI_USERDEFINED_OP,
    XMI_OP_COUNT
  }
    xmi_op;

  /**
   * \brief Message layer data types
   */

  typedef enum
  {
    /* Standard/Primative DT's */
    XMI_UNDEFINED_DT = 0,
    XMI_SIGNED_CHAR,
    XMI_UNSIGNED_CHAR,
    XMI_SIGNED_SHORT,
    XMI_UNSIGNED_SHORT,
    XMI_SIGNED_INT,
    XMI_UNSIGNED_INT,
    XMI_SIGNED_LONG_LONG,
    XMI_UNSIGNED_LONG_LONG,
    XMI_FLOAT,
    XMI_DOUBLE,
    XMI_LONG_DOUBLE,
    XMI_LOGICAL,
    XMI_SINGLE_COMPLEX,
    XMI_DOUBLE_COMPLEX,
    /* Max/Minloc DT's */
    XMI_LOC_2INT,
    XMI_LOC_SHORT_INT,
    XMI_LOC_FLOAT_INT,
    XMI_LOC_DOUBLE_INT,
    XMI_LOC_2FLOAT,
    XMI_LOC_2DOUBLE,
    XMI_USERDEFINED_DT,
    XMI_DT_COUNT
  }
    xmi_dt;


  /*****************************************************************************/
  /**
   * \defgroup CA Compact attributes
   * \{
   */
  /*****************************************************************************/

  /** \todo Should this be size_t ??? */
  typedef int xmi_ca_mask;

#define XMI_CA_MASK_NUM_BYTES  (sizeof(xmi_ca_mask))
#define XMI_CA_BYTE_SIZE       (sizeof(char))
#define XMI_CA_TOTAL_BITS      (XMI_CA_BYTE_SIZE * XMI_CA_MASK_NUM_BYTES) /**< \todo Either this definition is wrong, or the name is misleading; this is not a bit-count for the array */
#define XMI_CA_NUM_ELEMENTS    1

  /* compact list of informative attributes in the form of bits*/
  typedef struct
  {
    /* initially 1 list element of 32 bits, assuming sizeof(xmi_ca_mask)==4 */
    xmi_ca_mask bits[XMI_CA_NUM_ELEMENTS];
  } xmi_ca_t;

  /**
   * \brief A metadata structure to describe a collective protocol
   */
  typedef struct
  {
    xmi_ca_t geometry; /**< geometry attributes                   */
    xmi_ca_t buffer;   /**< buffer attributes (contig, alignment) */
    xmi_ca_t misc;     /**< other attributes (i.e. threaded)      */
    char name[32];     /**< name of algorithm                     */
  } xmi_metadata_t;

  extern void xmi_metadata_multiset(xmi_ca_t *, ...);

  /** \} */ /* end of "Compact attributes" group */


  /*****************************************************************************/
  /**
   * \defgroup activemessage xmi active messaging interface
   *
   * Some brief documentation on active message stuff ...
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief Hints for sending a message
   *
   * \todo better names for the hints
   * \todo better documentation for the hints
   */
  typedef struct
  {
    uint32_t consistency       : 1; /**< Force match ordering semantics                          */
    uint32_t recv_immediate    : 1; /**< Assert that sends will result in an 'immediate' receive */
    uint32_t buffer_registered : 1; /**< ???                                                     */
    uint32_t use_rdma          : 1; /**< Assert/enable rdma operations                           */
    uint32_t no_rdma           : 1; /**< Disable rdma operations                                 */
    uint32_t no_local_copy     : 1; /**< ???                                                     */
    uint32_t interrupt_on_recv : 1; /**< Interrupt the remote task when the first packet arrives */
    uint32_t high_priority     : 1; /**< Message is delivered with high priority,
                                       which may result in out-of-order delivery                 */
    uint32_t no_long_header    : 1; /**< Disable long header support                             */
    uint32_t use_shmem         : 1; /**< Assert/enable shared memory optimizations               */
    uint32_t no_shmem          : 1; /**< Disable shared memory optimizationss                    */

    uint32_t reserved          :21; /**< Unused at this time                                     */
  } xmi_send_hint_t;

  typedef struct
  {
    uint32_t reserved          :32; /**< Unused at this time                                     */
  } xmi_collective_hint_t;



  /**
   * \brief Active message send common parameters structure
   */
  typedef struct
  {
    struct iovec      header;   /**< Header buffer address and size in bytes */
    struct iovec      data;     /**< Data buffer address and size in bytes */
    size_t            dispatch; /**< Dispatch identifier */
    xmi_send_hint_t   hints;    /**< Hints for sending the message */
    xmi_endpoint_t    dest;     /**< Destination endpoint */
  } xmi_send_immediate_t;

  typedef struct
  {
    void               * cookie;   /**< Argument to \b all event callbacks */
    xmi_event_function   local_fn; /**< Local message completion event */
    xmi_event_function   remote_fn;/**< Remote message completion event */
  } xmi_send_event_t;

  /**
   * \brief Structure for send parameters unique to a simple active message send
   */
  typedef struct
  {
    xmi_send_immediate_t send;     /**< Common send parameters */
    xmi_send_event_t     events;   /**< Non-blocking event parameters */
  } xmi_send_t;

  /**
   * \brief Structure for send parameters unique to a typed active message send
   */
  typedef struct
  {
    xmi_send_immediate_t send;     /**< Common send parameters */
    xmi_send_event_t     events;   /**< Non-blocking event parameters */
    struct
    {
      size_t             offset;   /**< Starting offset from \code send.data.iov_base \endcode */
      xmi_type_t         datatype; /**< Datatype */
    } typed;                       /**< Typed send parameters */
  } xmi_send_typed_t;

  /**
   * \brief Non-blocking active message send for contiguous data
   *
   * A low-latency send operation may be enhanced by using a dispatch id which
   * was set with the \c recv_immediate hint bit enabled. This hint asserts
   * that all receives with the dispatch id will not exceed a certain limit.
   *
   * The implementation configuration attribute \c XMI_RECV_IMMEDIATE_MAX
   * defines the maximum size of data buffers that can be completely received
   * with a single dispatch callback. Typically this limit is associated with
   * a network resource attribute, such as a packet size.
   *
   * \see xmi_send_hint_t
   * \see XMI_Configuration_query
   *
   * \param[in] context    XMI communication context
   * \param[in] parameters Send simple parameter structure
   */
  xmi_result_t XMI_Send (xmi_context_t    context,
                         xmi_send_t     * parameters);

  /**
   * \brief Immediate active message send for small contiguous data
   *
   * The blocking send is only valid for small data buffers. The implementation
   * configuration attribute \c XMI_SEND_IMMEDIATE_MAX defines the upper
   * bounds for the size of data buffers, including header data, that can be
   * sent with this function. This function will return an error if a data
   * buffer larger than the \c XMI_SEND_IMMEDIATE_MAX is attempted.
   *
   * This function provides a low-latency send that can be optimized by the
   * specific xmi implementation. If network resources are immediately
   * available the send data will be injected directly into the network. If
   * resources are not available the specific xmi implementation may internally
   * buffer the send parameters and data until network resource are available
   * to complete the transfer. In either case the send will immediately return,
   * no doce callback is invoked, and is considered complete.
   *
   * The low-latency send operation may be further enhanced by using a dispatch
   * id which was set with the \c recv_immediate hint bit enabled. This hint
   * asserts that all receives with the dispatch id will not exceed a certain
   * limit.
   *
   * The implementation configuration attribute \c XMI_RECV_IMMEDIATE_MAX
   * defines the maximum size of data buffers that can be completely received
   * with a single dispatch callback. Typically this limit is associated with
   * a network resource attribute, such as a packet size.
   *
   * \see xmi_send_hint_t
   * \see XMI_Configuration_query
   *
   * \todo Better define send parameter structure so done callback is not required
   * \todo Define configuration attribute for the size limit
   *
   * \param[in] context    XMI communication context
   * \param[in] parameters Send parameter structure
   */
  xmi_result_t XMI_Send_immediate (xmi_context_t          context,
                                   xmi_send_immediate_t * parameters);

  /**
   * \brief Non-blocking active message send for non-contiguous typed data
   *
   * Transfers data according to a predefined data memory layout, or type, to
   * the remote task.
   *
   * Conceptually, the data is transfered as a byte stream which may be
   * received by the remote task into a different format, such as a contiguous
   * buffer or the same or different predefined type.
   *
   * \param[in] context    XMI communication context
   * \param[in] parameters Send typed parameter structure
   */
  xmi_result_t XMI_Send_typed (xmi_context_t      context,
                               xmi_send_typed_t * parameters);

  /**
   * \brief Active message receive hints
   */
  typedef struct
  {
    uint32_t inline_completion :  1; /**< The receive completion callback
                                      *   \b must be invoked by the thread that
                                      *   receives the dispatch notification. */
    uint32_t reserved          : 31; /**< Reserved. Do not use. */
  } xmi_recv_hint_t;

  /**
   * \brief Active message kind identifier
   */
  typedef enum {
    XMI_AM_KIND_SIMPLE = 0, /**< Simple contiguous data transfer */
    XMI_AM_KIND_TYPED       /**< Typed, non-contiguous, data transfer */
  } xmi_am_kind_t;

  /**
   * \brief Receive message structure
   *
   * This structure is initialized and then returned as an output parameter from
   * the active message dispatch callback to direct the xmi runtime how to
   * receive the data stream.
   *
   * \see xmi_dispatch_p2p_fn
   */
  typedef struct
  {
    xmi_recv_hint_t         hints;    /**< Hints for receiving the message */
    void                  * cookie;   /**< Argument to \b all event callbacks */
    xmi_event_function      local_fn; /**< Local message completion event */
    xmi_am_kind_t           kind;     /**< Which kind receive is to be done */
    union
    {
      struct
      {
        size_t              bytes;    /**< Number of bytes of data */
        void              * addr;     /**< Starting address of the buffer */
      } simple;                       /**< Contiguous buffer receive */
      struct
      {
        size_t              bytes;    /**< Number of bytes of data */
        void              * addr;     /**< Starting address of the buffer */
        xmi_type_t          type;     /**< Datatype */
        size_t              offset;   /**< Starting offset of the type */
      } typed;                        /**< Typed receive */
    } data;                           /**< Receive message destination information */
  } xmi_recv_t;

  /**
   * \brief Dispatch callback
   *
   * This single dispatch function type supports two kinds of receives:
   * "immediate" and "asynchronous".
   *
   * An immediate receive occurs when the dispatch function is invoked and all
   * of the data sent is \em immediately available in the buffer. In this case
   * \c pipe_addr will point to a valid memory location - even when the number
   * of bytes sent is zero, and the \c recv output structure will be \c NULL.
   *
   * An asynchronous receive occurs when the dispatch function is invoked and
   * all of the data sent is \b not immediately available. In this case the
   * application must provide information to direct how the receive will
   * complete. The \c recv output structure will point to a valid memory
   * location for this purpose, and the \c pipe_addr pointer will be \c NULL.
   * The \c data_size parameter will contain the number of bytes that are being
   * sent from the remote endpoint.
   *
   * \note A zero-byte send will \b always result in an immediate receive.
   *
   * \note The maximum number of bytes that may be immediately received can be
   *       queried with the \c XMI_RECV_IMMEDIATE configuration attribute.
   *
   * \see XMI_Configuration_query
   *
   * "pipe" has nothing to do with "PipeWorkQueue"s
   */
  typedef void (*xmi_dispatch_p2p_fn) (
    xmi_context_t        context,      /**< IN:  communication context which invoked the dispatch function */
    void               * cookie,       /**< IN:  dispatch cookie */
    void               * header_addr,  /**< IN:  header address  */
    size_t               header_size,  /**< IN:  header size     */
    void               * pipe_addr,    /**< IN:  address of XMI pipe  buffer, valid only if non-NULL        */
    size_t               data_size,    /**< IN:  number of byts of message data, valid regardless of message type */
    xmi_recv_t         * recv);        /**< OUT: receive message structure, only needed if addr is non-NULL */

  /** \} */ /* end of "active message" group */


  /*****************************************************************************/
  /**
   * \defgroup rma xmi remote memory access data transfer interface
   *
   * Some brief documentation on rma stuff ...
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief Common input parameters for all XMI rma functions
   **/
  typedef struct
  {
    xmi_endpoint_t       dest;      /**< Destination endpoint */
    xmi_send_hint_t      hints;     /**< Hints for sending the message */
    void               * local;     /**< Local transfer virtual address */
    void               * remote;    /**< Remote transfer virtual address */
    void               * cookie;    /**< Argument to \b all event callbacks */
    xmi_event_function   done_fn;   /**< Local completion event */
  } xmi_rma_t;

  /*****************************************************************************/
  /**
   * \defgroup put xmi remote memory access put transfer interface
   *
   * Some brief documentation on put stuff ...
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief Input parameter structure for simple put transfers
   */
  typedef struct
  {
    xmi_rma_t            rma;       /**< Common rma parameters */
    struct
    {
      size_t             bytes;     /**< Data transfer size in bytes */
      xmi_event_function rdone_fn;  /**< Remote completion event - all local
                                         data has been received by remote task */
    } put;                          /**< Parameters specific to put */
  } xmi_put_simple_t;

  /**
   * \brief Input parameter structure for typed put transfers
   */
  typedef struct
  {
    xmi_rma_t            rma;       /**< Common rma parameters */
    struct
    {
      size_t             bytes;     /**< Data transfer size in bytes */
      xmi_event_function rdone_fn;  /**< Remote completion event - all local
                                       data has been received by remote task */
      xmi_type_t         local;     /**< Data type of local buffer */
      xmi_type_t         remote;    /**< Data type of remote buffer */
    } put;                          /**< Parameters specific to put */
  } xmi_put_typed_t;

  /**
   * \brief One-sided put operation for simple contiguous data transfer
   *
   * \param[in] context    XMI communication context
   * \param[in] parameters Simple put input parameters
   */
  xmi_result_t XMI_Put (xmi_context_t      context,
                        xmi_put_simple_t * parameters);

  /**
   * \brief One-sided put operation for typed non-contiguous data transfer
   *
   * \param[in] context    XMI communication context
   * \param[in] parameters Typed put input parameters
   */
  xmi_result_t XMI_Put_typed (xmi_context_t     context,
                              xmi_put_typed_t * parameters);


  /** \} */ /* end of "put" group */

  /*****************************************************************************/
  /**
   * \defgroup get xmi remote memory access get transfer interface
   *
   * Some brief documentation on get stuff ...
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief Input parameter structure for simple get transfers
   */
  typedef struct
  {
    xmi_rma_t            rma;       /**< Common rma parameters */
    struct
    {
      size_t             bytes;     /**< Data transfer size in bytes */
    } get;                          /**< Parameters specific to get */
  } xmi_get_simple_t;

  /**
   * \brief Input parameter structure for typed get transfers
   */
  typedef struct
  {
    xmi_rma_t            rma;         /**< Common rma parameters */
    struct
    {
      size_t             bytes;     /**< Data transfer size in bytes */
      xmi_type_t         local;     /**< Data type of local buffer */
      xmi_type_t         remote;    /**< Data type of remote buffer */
    } get;                          /**< Parameters specific to get */
  } xmi_get_typed_t;

  /**
   * \brief One-sided get operation for simple contiguous data transfer
   *
   * \param[in] context    XMI communication context
   * \param[in] parameters Simple get input parameters
   */
  xmi_result_t XMI_Get (xmi_context_t      context,
                        xmi_get_simple_t * parameters);

  /**
   * \brief One-sided get operation for typed non-contiguous data transfer
   *
   * \param[in] context    XMI communication context
   * \param[in] parameters Typed get input parameters
   */
  xmi_result_t XMI_Get_typed (xmi_context_t     context,
                              xmi_get_typed_t * parameters);

  /** \} */ /* end of "get" group */

  /*****************************************************************************/
  /**
   * \defgroup rmw xmi remote memory access read-modify-write interface
   *
   * Some brief documentation on rmw stuff ...
   * \{
   */
  /*****************************************************************************/

  /** \brief Atomic rmw data type */
  typedef enum
  {
    XMI_RMW_KIND_UINT32      = 0x0001, /**< 32-bit unsigned integer operation */
    XMI_RMW_KIND_UINT64      = 0x0002  /**< 64-bit unsigned integer operation */
  } xmi_rmw_kind_t;

  /** \brief Atomic rmw assignment type */
  typedef enum
  {
    XMI_RMW_ASSIGNMENT_SET   = 0x0010, /**< =  operation */
    XMI_RMW_ASSIGNMENT_ADD   = 0x0020, /**< += operation */
    XMI_RMW_ASSIGNMENT_OR    = 0x0040  /**< |= operation */
  } xmi_rmw_assignment_t;

  /** \brief Atomic rmw comparison type */
  typedef enum
  {
    XMI_RMW_COMPARISON_NOOP  = 0x0100, /**< No comparison operation */
    XMI_RMW_COMPARISON_EQUAL = 0x0200  /**< Equality comparison operation */
  } xmi_rmw_comparison_t;

  typedef struct
  {
    xmi_rma_t               rma;       /**< Common rma parameters */
    struct
    {
      xmi_rmw_comparison_t  compare;   /**< read-modify-write comparison type */
      xmi_rmw_assignment_t  assign;    /**< read-modify-write assignment type */
      xmi_rmw_kind_t        kind;      /**< read-modify-write variable type */
      union
      {
        struct
        {
          uint32_t          value;     /**< 32-bit data value */
          uint32_t          test;      /**< 32-bit test value */
        } uint32;                      /**< 32-bit rmw input parameters */
        struct
        {
          uint64_t          value;     /**< 64-bit data value */
          uint64_t          test;      /**< 64-bit test value */
        } uint64;                      /**< 64-bit rmw input parameters */
      } input;
    } rmw;                             /**< Parameters specific to rmw */
  } xmi_rmw_t;

  /**
   * \brief Atomic read-modify-write operation to a remote memory location
   *
   * The specific operation is determined by the combination of the three rmw
   * identifier enumeration types. All operations will perform the same
   * generic logical atomic operation:
   *
   * \code
   * *result = *remote; (*remote COMPARISON test) ? *remote ASSIGNMENT value;
   * \endcode
   *
   * \warning All read-modify-write operations are \b unordered relative
   *          to all other data transfer operations - including other
   *          read-modify-write operations.
   *
   * Example read-modify-write operations include:
   *
   * \par XMI_RMW_KIND_UINT32 | XMI_RMW_COMPARISON_NOOP | XMI_RMW_ASSIGNMENT_ADD
   *      "32-bit unsigned integer fetch-and-add operation"
   * \code
   * uint32_t *result, *remote, value, test;
   * *result = *remote; *remote += value;
   * \endcode
   *
   * \par XMI_RMW_KIND_UINT32 | XMI_RMW_COMPARISON_NOOP | XMI_RMW_ASSIGNMENT_OR
   *      "32-bit unsigned integer fetch-and-or operation"
   * \code
   * uint32_t *result, *remote, value, test;
   * *result = *remote; *remote |= value;
   * \endcode
   *
   * \par XMI_RMW_KIND_UINT64 | XMI_RMW_COMPARISON_NOOP | XMI_RMW_ASSIGNMENT_SET
   *      "64-bit unsigned integer swap (fetch-and-set) operation"
   * \code
   * uint64_t *result, *remote, value, test;
   * *result = *remote; *remote = value;
   * \endcode
   *
   * \par XMI_RMW_KIND_UINT64 | XMI_RMW_COMPARISON_EQUAL | XMI_RMW_ASSIGNMENT_SET
   *      "64-bit unsigned integer compare-and-swap operation"
   * \code
   * uint64_t *result, *remote, value, test;
   * *result = *remote; (*remote == test) ? *remote = value;
   * \endcode
   *
   * \param[in] context    XMI communication context
   * \param[in] parameters read-modify-write input parameters
   */
  xmi_result_t XMI_Rmw (xmi_context_t context, xmi_rmw_t * parameters);

  /** \} */ /* end of "rmw" group */

  /*****************************************************************************/
  /**
   * \defgroup rdma xmi remote memory access rdma interfaces
   *
   * Some brief documentation on rdma stuff ...
   * \{
   */
  /*****************************************************************************/

  typedef void * xmi_memregion_t; /**< ??? */

  /**
   * \brief Default "global" memory region
   *
   * The global memory region may be used in the one-sided operations to make use
   * of the system-managed memory region support.
   *
   * User-managed memory regions may result in higher performance for one-sided
   * operations due to system memory region caching, internal memory region
   * exchange operations, and other implementation-specific management features.
   */
  extern xmi_memregion_t XMI_MEMREGION_GLOBAL;

  /**
   * \brief Register a local memory region for one sided operations
   *
   * The local memregion may be transfered, via a send message, to a remote task
   * to allow the remote task to perform one-sided operations with this local
   * task
   *
   * \todo Define, exactly, what the sematics are if a NULL pointer is passed
   *       as the memregion to initialize.
   *
   * \param[in]  context   XMI application context
   * \param[in]  address   Virtual address of memory region
   * \param[in]  bytes     Number of bytes to register
   * \param[out] memregion Memory region object. Can be NULL.
   */
  xmi_result_t XMI_Memregion_register (xmi_context_t     context,
                                       void            * address,
                                       size_t            bytes,
                                       xmi_memregion_t * memregion);

  /**
   * \brief Deregister a local memory region for one sided operations
   *
   * It is illegal to deregister the "global" memory region.
   *
   * \param[in] context   XMI application context
   * \param[in] memregion Memory region object
   */
  xmi_result_t XMI_Memregion_deregister (xmi_context_t   context,
                                         xmi_memregion_t memregion);

  /**
   * \brief Query the attributes of a memory region
   *
   * \todo Should the communication context be an output parameter?
   *
   * \param[in]  context   XMI application context
   * \param[in]  memregion Memory region object
   * \param[out] address   Base virtual address
   * \param[out] bytes     Number of contiguous bytes from the base address
   * \param[out] task      XMI task that registered the memory region
   */
  xmi_result_t XMI_Memregion_query (xmi_context_t      context,
                                    xmi_memregion_t    memregion,
                                    void            ** address,
                                    size_t           * bytes,
                                    size_t           * task);


  /**
   * \brief Input parameter structure for simple rput transfers
   */
  typedef struct
  {
    xmi_rma_t              rma;       /**< Common rma parameters */
    struct
    {
      xmi_event_function   remote_fn; /**< Remote completion event - all local
                                         data has been received by remote task */
      xmi_memregion_t      local_mr;  /**< Local buffer memory region */
      xmi_memregion_t      remote_mr; /**< Remote buffer memory region */
    } rput;                           /**< Parameters specific to rput */
  } xmi_rput_simple_t;

  /**
   * \brief Input parameter structure for typed put transfers
   */
  typedef struct
  {
    xmi_rma_t              rma;       /**< Common rma parameters */
    struct
    {
      xmi_event_function   remote_fn; /**< Remote completion event - all local
                                           data has been received by remote task */
      xmi_type_t           local;     /**< Data type of local buffer */
      xmi_type_t           remote;    /**< Data type of remote buffer */
      xmi_memregion_t      local_mr;  /**< Local buffer memory region */
      xmi_memregion_t      remote_mr; /**< Remote buffer memory region */
    } rput;                           /**< Parameters specific to rput */
  } xmi_rput_typed_t;


  /**
   * \brief Simple put operation for one-sided contiguous data transfer.
   *
   * \param[in] context    XMI application context
   * \param[in] parameters Input parameters structure
   */
  xmi_result_t XMI_Rput (xmi_context_t context, xmi_rput_simple_t * parameters);

  /**
   * \brief Put operation for data type specific one-sided data transfer.
   *
   * \param[in] context    XMI application context
   * \param[in] parameters Input parameters structure
   */
  xmi_result_t XMI_Rput_typed (xmi_context_t context, xmi_rput_typed_t * parameters);

  /**
   * \brief Input parameter structure for simple rput transfers
   */
  typedef struct
  {
    xmi_rma_t          rma;           /**< Common rma parameters */
    struct
    {
      xmi_memregion_t  local_mr;      /**< Local buffer memory region */
      xmi_memregion_t  remote_mr;     /**< Remote buffer memory region */
      size_t           local_offset;
      size_t           remote_offset;
      size_t           bytes;         /**< Data transfer size in bytes */
    } rget;                           /**< Parameters specific to rget */
  } xmi_rget_simple_t;

  /**
   * \brief Input parameter structure for typed put transfers
   */
  typedef struct
  {
    xmi_rma_t          rma;           /**< Common rma parameters */
    struct
    {
      xmi_type_t       local;         /**< Data type of local buffer */
      xmi_type_t       remote;        /**< Data type of remote buffer */
      xmi_memregion_t  local_mr;      /**< Local buffer memory region */
      xmi_memregion_t  remote_mr;     /**< Remote buffer memory region */
    } rget;                           /**< Parameters specific to rget */
  } xmi_rget_typed_t;

  /**
   * \brief Simple get operation for one-sided contiguous data transfer.
   *
   * \param[in] context    XMI application context
   * \param[in] parameters Input parameters structure
   */
  xmi_result_t XMI_Rget (xmi_context_t context, xmi_rget_simple_t * parameters);

  /**
   * \brief Get operation for data type specific one-sided data transfer.
   *
   * \param[in] context    XMI application context
   * \param[in] parameters Input parameters structure
   */
  xmi_result_t XMI_Rget_typed (xmi_context_t context, xmi_rget_typed_t * parameters);

  /** \} */ /* end of "rdma" group */
  /** \} */ /* end of "rma" group */



  /*****************************************************************************/
  /**
   * \defgroup dynamictasks xmi dynamic task interface
   *
   * Some brief documentation on dynamic task stuff ...
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief Clean up local resources to an endpoint in preparation for
   *        task shutdown or checkpoint
   *
   *        It is the user of this API's responsibility to ensure
   *        that all communication has been quiesced to and from
   *        the destination via a fence call and synchronization
   *
   * \param[in] context    XMI communication context
   * \param[in] dest       Array of destination endpoints to close connections to
   * \param[in] count      Number of endpoints in the array dest
   */

  xmi_result_t XMI_Purge (xmi_context_t    context,
                          xmi_endpoint_t * dest,
                          size_t           count);

  /**
   * \brief Setup local resources to an endpoint in preparation for
   *        task restart or creation
   *
   * \param[in] context    XMI communication context
   * \param[in] dest       Array of destination endpoints to resume connections to
   * \param[in] count      Number of endpoints in the array dest
   */
  xmi_result_t XMI_Resume (xmi_context_t    context,
                           xmi_endpoint_t * dest,
                           size_t           count);

  /** \} */ /* end of "dynamic tasks" group */


  /*****************************************************************************/
  /**
   * \defgroup sync xmi memory synchronization and data fence interface
   *
   * Some brief documentation on sync stuff ...
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief Begin a memory synchronization region
   *
   * A fence region is defined as an area of program control on the local task
   * bounded by the XMI_Fence_begin() and XMI_Fence_end() functions.
   *
   * \warning It is considered \b illegal to invoke a fence operation outside of
   *          a fence region.
   *
   * \warning It is considered \b illegal to begin a fence region inside an
   *          existing fence region. Fence regions can not be nested.
   *
   * \param[in] context XMI communication context
   */
  xmi_result_t XMI_Fence_begin (xmi_context_t context);

  /**
   * \brief End a memory synchronization region
   *
   * A fence region is defined as an area of program control on the local task
   * bounded by the XMI_Fence_begin() and XMI_Fence_end() functions.
   *
   * \warning It is considered \b illegal to invoke a fence operation outside of
   *          a fence region.
   *
   * \warning It is considered \b illegal to end a fence region outside of an
   *          existing fence region.
   *
   * \param[in] context XMI communication context
   */
  xmi_result_t XMI_Fence_end (xmi_context_t context);


  /**
   * \brief Syncronize all transfers between all endpoints on a context.
   *
   * \param[in] context XMI communication context
   * \param[in] done_fn Event callback to invoke when the fence is complete
   * \param[in] cookie  Event callback argument
   */
  xmi_result_t XMI_Fence_all (xmi_context_t        context,
                              xmi_event_function   done_fn,
                              void               * cookie);

  /**
   * \brief Syncronize all transfers to an endpoints.
   *
   * \param[in] context XMI communication context
   * \param[in] done_fn Event callback to invoke when the fence is complete
   * \param[in] cookie  Event callback argument
   * \param[in] target  Endpoint to synchronize
   */
  xmi_result_t XMI_Fence_endpoint (xmi_context_t        context,
                                   xmi_event_function   done_fn,
                                   void               * cookie,
                                   xmi_endpoint_t       target);

  /** \} */ /* end of "sync" group */


  /* ************************************************************************* */
  /* ********* Transfer Types, used by geometry and xfer routines ************ */
  /* ************************************************************************* */
  typedef enum
  {
    XMI_XFER_BROADCAST = 0,
    XMI_XFER_ALLREDUCE,
    XMI_XFER_REDUCE,
    XMI_XFER_ALLGATHER,
    XMI_XFER_ALLGATHERV,
    XMI_XFER_ALLGATHERV_INT,
    XMI_XFER_SCATTER,
    XMI_XFER_SCATTERV,
    XMI_XFER_SCATTERV_INT,
    XMI_XFER_BARRIER,
    XMI_XFER_ALLTOALL,
    XMI_XFER_ALLTOALLV,
    XMI_XFER_ALLTOALLV_INT,
    XMI_XFER_SCAN,
    XMI_XFER_AMBROADCAST,
    XMI_XFER_AMSCATTER,
    XMI_XFER_AMGATHER,
    XMI_XFER_AMREDUCE,
    XMI_XFER_COUNT
  } xmi_xfer_type_t;

  /* ************************************************************************* */
  /* **************     Geometry (like groups/communicators)  **************** */
  /* ************************************************************************* */

  typedef void*   xmi_geometry_t;
  typedef size_t  xmi_algorithm_t;

  typedef struct
  {
    size_t lo, hi;
  }
    xmi_geometry_range_t;

  /**
   * \brief Initialize the geometry
   *        A synchronizing operation will take place during geometry_initialize
   *        on the parent geometry
   *        If the output geometry "geometry" is NULL, then no geometry will be
   *        created, however, all nodes in the parent must participate in the
   *        geometry_initialize operation, even if they do not create a geometry
   *
   * \param[in]  client         xmi client
   * \param[out] geometry        Opaque geometry object to initialize
   * \param[in] parent          Parent geometry containing all the nodes in the task list
   * \param[in]  id              Identifier for this geometry
   *                             which uniquely represents this geometry(if tasks overlap)
   * \param[in]  task_slices     Array of node slices participating in the geometry
   *                             User must keep the array of slices in memory for the
   *                             duration of the geometry's existence
   * \param[in]  slice_count     Number of task slices participating in the geometry
   * \param[in]  context         context to deliver async callback to
   * \param[in]  fn              event function to call when geometry has been created
   * \param[in]  cookie          user cookie to deliver with the callback
   */

  xmi_result_t XMI_Geometry_create_taskrange (xmi_client_t                client,
                                        xmi_geometry_t            * geometry,
                                              xmi_geometry_t              parent,
                                        unsigned                    id,
                                        xmi_geometry_range_t      * task_slices,
                                              size_t                      slice_count,
                                              xmi_context_t               context,
                                              xmi_event_function          fn,
                                              void                      * cookie);

   /**
   * \brief Initialize the geometry
   *        A synchronizing operation will take place during geometry_initialize
   *        on the parent geometry
   *        If the output geometry "geometry" is NULL, then no geometry will be
   *        created, however, all nodes in the parent must participate in the
   *        geometry_initialize operation, even if they do not create a geometry
   *
   * \param[in]  client         xmi client
   * \param[out] geometry        Opaque geometry object to initialize
   * \param[in] parent          Parent geometry containing all the nodes in the task list
   * \param[in]  id              Identifier for this geometry
   *                             which uniquely represents this geometry(if tasks overlap)
   * \param[in]  tasks           Array of tasks to build the geometry list
   *                             User must keep the task list in memory
   *                             duration of the geometry's existence
   * \param[in]  task_count      Number of tasks participating in the geometry
   * \param[in]  context         context to deliver async callback to
   * \param[in]  fn              event function to call when geometry has been created
   * \param[in]  cookie          user cookie to deliver with the callback
   */

  xmi_result_t XMI_Geometry_create_tasklist (xmi_client_t                client,
                                             xmi_geometry_t            * geometry,
                                             xmi_geometry_t              parent,
                                             unsigned                    id,
                                             xmi_task_t                * tasks,
                                             size_t                      task_count,
                                             xmi_context_t               context,
                                             xmi_event_function          fn,
                                             void                      * cookie);

  /**
   * \brief Initialize the geometry
   *
   * \param[in]  client          xmi client
   * \param[in]  world_geometry  world geometry object
   */
  xmi_result_t XMI_Geometry_world (xmi_client_t                client,
                                   xmi_geometry_t            * world_geometry);

  /**
   * \brief determines the number of algorithms available for a given op
   *        in the two different lists (always work list,
   *        under-cetain conditions list).
   *
   * \param[in]     context       xmi context
   * \param[in]     geometry      An input geometry to be analyzed.
   * \param[in]     coll_type     type of collective op.
   * \param[in/out] lists_lengths array of 2 numbers representing all valid
   algorithms and optimized algorithms.
   * \retval        XMI_SUCCESS   number of algorithms is determined.
   * \retval        ?????         There is an error with input parameters
   */
  xmi_result_t XMI_Geometry_algorithms_num (xmi_context_t context,
                                            xmi_geometry_t geometry,
                                            xmi_xfer_type_t coll_type,
                                            int              *lists_lengths);

  /**
   * \brief fills in the protocols and attributes for a set of algorithms
   *        The first lists are used to populate collectives that work under
   *        any condidtion.  The second lists are used to populate
   *        collectives that the metadata must be checked before use
   *
   * \param[in]     context        xmi context
   * \param[in]     coll_type      type of collective op.
   * \param[in/out] algs0          array of algorithms to query
   * \param[in/out] mdata0         metadata array to be filled in if algorithms
   *                               are applicable, can be NULL.
   * \param[in]     num0           number of algorithms to fill in.
   * \param[in/out] algs1          array of algorithms to query
   * \param[in/out] mdata1         metadata array to be filled in if algorithms
   *                               are applicable, can be NULL.
   * \param[in]     num1           number of algorithms to fill in.
   * \retval        XMI_SUCCESS    algorithm is applicable to geometry.
   * \retval        ?????          Error in input arguments or not applicable.
   */
  xmi_result_t XMI_Geometry_algorithms_info (xmi_context_t context,
                                             xmi_geometry_t geometry,
                                             xmi_xfer_type_t  colltype,
                                             xmi_algorithm_t *algs0,
                                             xmi_metadata_t  *mdata0,
                                             int              num0,
                                             xmi_algorithm_t *algs1,
                                             xmi_metadata_t  *mdata1,
                                             int              num1);

  /**
   * \brief Free any memory allocated inside of a geometry.
   * \param[in] client   xmi client
   * \param[in] geometry The geometry object to free
   * \retval XMI_SUCCESS Memory free didn't fail
   */
  xmi_result_t XMI_Geometry_destroy(xmi_client_t    client,
                                     xmi_geometry_t  geometry);

  /**
   * \brief Create and post a non-blocking alltoall vector operation.
   *
   * The alltoallv operation ...
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sndbuf       The base address of the buffers containing data to be sent
   * \param[in]  stype        A single type datatype
   * \param[in]  stypecounts  An array of type replication counts.  Size of geometry length
   * \param[in]  sdispls      Array of offsets into the sndbuf.  Size of geometry length
   * \param[out] rcvbuf       The base address of the buffer for data reception
   * \param[in]  rtype        A single type datatype
   * \param[in]  rtypecounts  Array of type replication counts.  Size of geometry length
   * \param[in]  rdispls      Array of offsets into the rcvbuf.  Size of geometry length
   *
   * \retval     0            Success
   *
   */
  typedef struct
  {
    char                     * sndbuf;
    xmi_type_t               * stype;
    size_t                   * stypecounts;
    size_t                   * sdispls;
    char                     * rcvbuf;
    xmi_type_t               * rtype;
    size_t                   * rtypecounts;
    size_t                   * rdispls;
  } xmi_alltoallv_t;

  /**
   * \brief Create and post a non-blocking alltoall vector operation.
   *
   * The alltoallv_int operation ...
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sndbuf       The base address of the buffers containing data to be sent
   * \param[in]  stype        A single type datatype
   * \param[in]  stypecounts  An array of type replication counts.  Size of geometry length
   * \param[in]  sdispls      Array of offsets into the sndbuf.  Size of geometry length
   * \param[out] rcvbuf       The base address of the buffer for data reception
   * \param[in]  rtype        A single type datatype
   * \param[in]  rtypecounts  Array of type replication counts.  Size of geometry length
   * \param[in]  rdispls      Array of offsets into the rcvbuf.  Size of geometry length
   *
   * \retval     0            Success
   *
   */
  typedef struct
  {
    char                    * sndbuf;
    xmi_type_t              * stype;
    int                     * stypecounts;
    int                     * sdispls;
    char                    * rcvbuf;
    xmi_type_t              * rtype;
    int                     * rtypecounts;
    int                     * rdispls;
  } xmi_alltoallv_int_t;


  /**
   * \brief Create and post a non-blocking alltoall operation.
   * The alltoall operation ...
   *
   * \param[in]  cb_done     Callback to invoke when message is complete.
   * \param[in]  geometry    Geometry to use for this collective operation.
   * \param[in]  sndbuf      The base address of the buffers containing data to be sent
   * \param[in]  stype       Single datatype of the send buffer
   * \param[in]  stypecount  Single type replication count
   * \param[out] rbuf        The base address of the buffer for data reception
   * \param[in]  rtype       Single datatype of the receive buffer
   * \param[in]  rtypecount  Single type replication count
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    char                      * sndbuf;
    xmi_type_t                * stype;
    size_t                      stypecount;
    char                      * rcvbuf;
    xmi_type_t                * rtype;
    size_t                      rtypecount;
  } xmi_alltoall_t;

  /**
   * \brief Create and post a non-blocking reduce operation.
   * The reduce operation ...
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  root         Task ID of the reduce root node.
   * \param[in]  sbuffer      Source buffer.
   * \param[in]  stype        Source buffer type
   * \param[in]  stypecount   Source buffer type count
   * \param[in]  rbuffer      Receive buffer.
   * \param[in]  rtype        Receive buffer layout
   * \param[in]  rtypecount   Receive buffer type count
   * \param[in]  dt           Element data type
   * \param[in]  op           Reduce operation
   *
   * \retval     0            Success
   */
  typedef struct
  {
    size_t                     root;
    char                     * sndbuf;
    xmi_type_t               * stype;
    size_t                     stypecount;
    char                     * rcvbuf;
    xmi_type_t               * rtype;
    size_t                     rtypecount;
    xmi_dt                     dt;
    xmi_op                     op;
  } xmi_reduce_t;

  /**
   * \brief Create and post a non-blocking reduce_scatter operation.
   *
   * The reduce_scatter operation ...
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sbuffer      Source buffer.
   * \param[in]  stype        Source buffer type
   * \param[in]  stypecount   Source buffer type count
   * \param[in]  rbuffer      Receive buffer.
   * \param[in]  rtype        Receive buffer layout
   * \param[in]  rtypecount   Receive buffer type count
   * \param[in]  rcounts      number of elements to receive from the destinations(common on all nodes)
   * \param[in]  dt           Element data type
   * \param[in]  op           Reduce operation
   *
   * \retval     0            Success
   *
   */
  typedef struct
  {
    char                    * sndbuf;
    xmi_type_t              * stype;
    size_t                    stypecount;
    char                    * rcvbuf;
    xmi_type_t              * rtype;
    size_t                    rtypecount;
    size_t                  * rcounts;
    xmi_dt                    dt;
    xmi_op                    op;
  } xmi_reduce_scatter_t;

  /**
   * \brief Create and post a non-blocking broadcast operation.
   *
   * The broadcast operation ...
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  root         Task ID of the node performing the broadcast.
   * \param[in]  buf          Source buffer to broadcast on root, dest buffer on non-root
   * \param[in]  type         data type layout, may be different on root/destinations
   * \param[in]  count        Single type replication count
   *
   * \retval     0            Success
   *
   */
  typedef struct
  {
    size_t                      root;
    char                      * buf;
    xmi_type_t                * type;
    size_t                      typecount;
  } xmi_broadcast_t;


  /**
   * \brief Create and post a non-blocking allgather
   *
   * The allgather
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  src          Source buffer to send
   * \param[in]  stype        data layout of send buffer
   * \param[in]  stypecount   replication count of the type
   * \param[in]  rcv          Source buffer to receive the data
   * \param[in]  rtype        data layout of each receive buffer
   * \param[in]  rtypecount   replication count of the type
   *
   * \retval     0            Success
   *
   */
  typedef struct
  {
    char                      * sndbuf;
    xmi_type_t                * stype;
    size_t                      stypecount;
    char                      * rcvbuf;
    xmi_type_t                * rtype;
    size_t                      rtypecount;
  } xmi_allgather_t;


  /**
   * \brief Create and post a non-blocking allgather
   *
   * The gather
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  root         The root node of the gather operation
   * \param[in]  src          Source buffer to send
   * \param[in]  stype        data layout of send buffer
   * \param[in]  stypecount   replication count of the type
   * \param[in]  rcv          Source buffer to receive the data
   * \param[in]  rtype        data layout of each receive buffer
   * \param[in]  rtypecount   replication count of the type
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                      root;
    char                      * sndbuf;
    xmi_type_t                * stype;
    size_t                      stypecount;
    char                      * rcvbuf;
    xmi_type_t                * rtype;
    size_t                      rtypecount;
  } xmi_gather_t;

  /**
   * \brief Create and post a non-blocking gatherv
   *
   * The gatherv
   *
   * \param[in]  request      Opaque memory to maintain internal message state.
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  root         The root node for the gatherv operation
   * \param[in]  sndbuf       The base address of the buffers containing data to be sent
   * \param[in]  stype        A single type datatype
   * \param[in]  stypecount   type replication count.
   * \param[out] rcvbuf       The base address of the buffer for data reception
   * \param[in]  rtype        A single type datatype
   * \param[in]  rtypecounts  Array of type replication counts.  Size of geometry length
   * \param[in]  rdispls      Array of offsets into the rcvbuf.  Size of geometry length
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                     root;
    char                     * sndbuf;
    xmi_type_t               * stype;
    size_t                     stypecount;
    char                     * rcvbuf;
    xmi_type_t               * rtype;
    size_t                   * rtypecounts;
    size_t                   * rdispls;
  } xmi_gatherv_t;

  /**
   * \brief Create and post a non-blocking gatherv
   *
   * The gatherv_int routine
   *
   * \param[in]  request      Opaque memory to maintain internal message state.
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  root         The root node for the gatherv operation
   * \param[in]  sndbuf       The base address of the buffers containing data to be sent
   * \param[in]  stype        A single type datatype
   * \param[in]  stypecount   type replication count.
   * \param[out] rcvbuf       The base address of the buffer for data reception
   * \param[in]  rtype        A single type datatype
   * \param[in]  rtypecounts  Array of type replication counts.  Size of geometry length
   * \param[in]  rdispls      Array of offsets into the rcvbuf.  Size of geometry length
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                     root;
    char                     * sndbuf;
    xmi_type_t               * stype;
    int                        stypecount;
    char                     * rcvbuf;
    xmi_type_t               * rtype;
    int                      * rtypecounts;
    int                      * rdispls;
  } xmi_gatherv_int_t;


  /**
   * \brief Create and post a non-blocking allgatherv
   *
   * The allgatherv
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sndbuf       The base address of the buffers containing data to be sent
   * \param[in]  stype        A single type datatype
   * \param[in]  stypecount   type replication count.
   * \param[out] rcvbuf       The base address of the buffer for data reception
   * \param[in]  rtype        A single type datatype
   * \param[in]  rtypecounts  Array of type replication counts.  Size of geometry length
   * \param[in]  rdispls      Array of offsets into the rcvbuf.  Size of geometry length
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    char                     * sndbuf;
    xmi_type_t               * stype;
    size_t                     stypecount;
    char                     * rcvbuf;
    xmi_type_t               * rtype;
    size_t                   * rtypecounts;
    size_t                   * rdispls;
  } xmi_allgatherv_t;

  /**
   * \brief Create and post a non-blocking allgatherv
   *
   * The allgatherv_int
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sndbuf       The base address of the buffers containing data to be sent
   * \param[in]  stype        A single type datatype
   * \param[in]  stypecount   type replication count.
   * \param[out] rcvbuf       The base address of the buffer for data reception
   * \param[in]  rtype        A single type datatype
   * \param[in]  rtypecounts  Array of type replication counts.  Size of geometry length
   * \param[in]  rdispls      Array of offsets into the rcvbuf.  Size of geometry length
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    char                     * sndbuf;
    xmi_type_t               * stype;
    int                        stypecount;
    char                     * rcvbuf;
    xmi_type_t               * rtype;
    int                      * rtypecounts;
    int                      * rdispls;
  } xmi_allgatherv_int_t;


  /**
   * \brief Create and post a non-blocking scatter
   *
   * The scatter
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  root         Task ID of the reduce root node.
   * \param[in]  sbuffer      Source buffer.
   * \param[in]  stype        Source buffer type
   * \param[in]  stypecount   Source buffer type count
   * \param[in]  rbuffer      Receive buffer.
   * \param[in]  rtype        Receive buffer layout
   * \param[in]  rtypecount   Receive buffer type count
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                      root;
    char                      * sndbuf;
    xmi_type_t                * stype;
    size_t                      stypecount;
    char                      * rcvbuf;
    xmi_type_t                * rtype;
    size_t                      rtypecount;
  } xmi_scatter_t;

  /**
   * \brief Create and post a non-blocking scatterv
   *
   * The scatterv
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sndbuf       The base address of the buffers containing data to be sent
   * \param[in]  stype        A single type datatype
   * \param[in]  stypecounts  An array of type replication counts.  Size of geometry length
   * \param[in]  sdispls      Array of offsets into the sndbuf.  Size of geometry length
   * \param[in]  rbuffer      Receive buffer.
   * \param[in]  rtype        A single type datatype
   * \param[in]  rtypecount   Receive buffer type replication count
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                      root;
    char                      * sndbuf;
    xmi_type_t                * stype;
    size_t                    * stypecounts;
    size_t                    * sdispls;
    char                      * rcvbuf;
    xmi_type_t                * rtype;
    size_t                      rtypecount;
  } xmi_scatterv_t;

  /**
   * \brief Create and post a non-blocking scatterv
   *
   * The scatterv_int
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sndbuf       The base address of the buffers containing data to be sent
   * \param[in]  stype        A single type datatype
   * \param[in]  stypecounts  An array of type replication counts.  Size of geometry length
   * \param[in]  sdispls      Array of offsets into the sndbuf.  Size of geometry length
   * \param[in]  rbuffer      Receive buffer.
   * \param[in]  rtype        A single type datatype
   * \param[in]  rtypecount   Receive buffer type replication count
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                      root;
    char                      * sndbuf;
    xmi_type_t                * stype;
    int                       * stypecounts;
    int                       * sdispls;
    char                      * rcvbuf;
    xmi_type_t                * rtype;
    int                         rtypecount;
  } xmi_scatterv_int_t;


  /**
   * \brief Create and post a non-blocking allreduce operation.
   *
   * The allreduce operation ...
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sbuffer      Source buffer.
   * \param[in]  stype        Source buffer type
   * \param[in]  stypecount   Source buffer type count
   * \param[in]  rbuffer      Receive buffer.
   * \param[in]  rtype        Receive buffer layout
   * \param[in]  rtypecount   Receive buffer type count
   * \param[in]  dt           Element data type
   * \param[in]  op           Reduce operation
   *
   * \retval     0            Success
   *
   * \todo doxygen
   * \todo discuss collapsing XMI_dt into type type.
   */
  typedef struct
  {
    char                     * sndbuf;
    xmi_type_t               * stype;
    size_t                     stypecount;
    char                     * rcvbuf;
    xmi_type_t               * rtype;
    size_t                     rtypecount;
    xmi_dt                     dt;
    xmi_op                     op;
  } xmi_allreduce_t;


  /**
   * \brief Create and post a non-blocking scan operation.
   *
   * The scan operation ...
   *
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \param[in]  geometry     Geometry to use for this collective operation.
   * \param[in]  sbuffer      Source buffer.
   * \param[in]  stype        Source buffer type
   * \param[in]  stypecount   Source buffer type count
   * \param[in]  rbuffer      Receive buffer.
   * \param[in]  rtype        Receive buffer layout
   * \param[in]  rtypecount   Receive buffer type count
   * \param[in]  dt           Element data type
   * \param[in]  op           Reduce operation
   * \param[in]  exclusive    scan operation is exclusive of current node?
   *
   * \retval     0            Success
   *
   * \todo doxygen
   * \todo discuss collapsing XMI_dt into type type.
   */
  typedef struct
  {
    char                     * sndbuf;
    xmi_type_t               * stype;
    size_t                     stypecount;
    char                     * rcvbuf;
    xmi_type_t               * rtype;
    size_t                     rtypecount;
    xmi_dt                     dt;
    xmi_op                     op;
    int                        exclusive;
  } xmi_scan_t;

  /**
   * \brief Create and post a non-blocking barrier operation.
   * The barrier operation ...
   * \param      geometry     Geometry to use for this collective operation.
   * \param[in]  cb_done      Callback to invoke when message is complete.
   * \retval  0            Success
   *
   * \see XMI_Barrier_register
   *
   * \todo doxygen
   */
  typedef struct
  {
  } xmi_barrier_t;


  /**
   * \brief Create and post a non-blocking active message broadcast operation.
   * The Active Message broadcast operation ...
   *
   * This differs from AMSend in only one particular: it takes geometry/team
   * as an argument. The semantics are as follows: the included header and data
   * are broadcast to every place in the team. The completion handler is invoked
   * on the sender side as soon as send buffers can be reused. On the receive
   * side the usual two-phase reception protocol is executed: a header handler
   * determines the address to which to deposit the data and sets the address
   * of a receive completion hander to be invoked once the data has arrived.
   *
   * \param[in]  dispatch     registered dispatch id to use
   * \param[in]  user_header  single metadata to send to destination in the header
   * \param[in]  headerlen    length of the metadata (can be 0)
   * \param[in]  src          Base source buffer to broadcast.
   * \param[in]  stype        Datatype of the send buffer
   * \param[in]  stypecount   replication count of the send buffer data type
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                      dispatch;
    void                      * user_header;
    size_t                      headerlen;
    void                      * sndbuf;
    xmi_type_t                * stype;
    size_t                      stypecount;
  } xmi_ambroadcast_t;
  /**
   * \brief The active message callback function, delivered to the user
   * \param[in]   root       system defined metadata:  root initiating the broadcast
   * \param[in]   comm       system defined metadata:  geometry id of the broadcast
   * \param[in]   sndlen     system defined metadata:  total number of bytes of the send
   * \param[in]   user_header user defined metadata:  active message header
   * \param[in]   headerlen  length of the user defined header (may be 0 bytes)
   * \param[out]  rcvbuf     target buffer for the incoming collective
   * \param[out]  rtype      data layout of the incoming collective
   * \param[out]  rtypecount replication count of the incoming collective
   * \param[out]  cb_info    data done callback to call on completion
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef void (*xmi_dispatch_ambroadcast_fn) (xmi_context_t         context,
                                               size_t                root,
                                               xmi_geometry_t        geometry,
                                               const size_t          sndlen,
                                               void                * user_header,
                                               const size_t          headerlen,
                                               void               ** rcvbuf,
                                               xmi_type_t          * rtype,
                                               size_t              * rtypecount,
                                               xmi_event_function  * const cb_info,
                                               void               ** cookie);


  /**
   * \brief Create and post a non-blocking active message scatter operation.
   * The Active Message scatter operation ...
   *
   * This is slightly more complicated than an AMBroadcast, because it allows
   * different headers and data buffers to be sent to everyone in the team.
   *
   * \param[in]  dispatch     registered dispatch id to use
   * \param[in]  headers      array of  metadata to send to destination
   * \param[in]  headerlength length of every header in the headers array
   * \param[in]  src          Base source buffer to scatter (size of geometry)
   * \param[in]  stype        single Datatype of the send buffer
   * \param[in]  stypecount   replication count of the send buffer data type
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                      dispatch;
    void                      * headers;
    size_t                      headerlen;
    void                      * sndbuf;
    xmi_type_t                * stype;
    size_t                      stypecount;
  } xmi_amscatter_t;
  /**
   * \brief The active message callback function, delivered to the user
   * \param[in]   root       system defined metadata:  root initiating the scatter
   * \param[in]   comm       system defined metadata:  geometry id of the scatter
   * \param[in]   sndlen     system defined metadata:  total number of bytes of the send
   * \param[in]   user_header user defined metadata:  active message header
   * \param[in]   headerlen  length of the user defined header (may be 0 bytes)
   * \param[out]  rcvbuf     target buffer for the incoming collective
   * \param[out]  rtype      data layout of the incoming collective
   * \param[out]  rtypecount replication count of the incoming collective
   * \param[out]  cb_info    data done callback to call on completion
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef void (*xmi_dispatch_amscatter_fn) (size_t               root,
                                             xmi_geometry_t       geometry,
                                             const unsigned       sndlen,
                                             void               * user_header,
                                             const size_t         headerlen,
                                             void              ** rcvbuf,
                                             xmi_type_t         * rtype,
                                             size_t             * rtypecount,
                                             xmi_event_function * const cb_info);

  /**
   * \brief Create and post a non-blocking active message gather operation.
   * The Active Message gather operation ...
   *
   * This is the reverse of amscatter. It works as follows. The header only,
   * no data, is broadcast to the team. Each place in the team executes the
   * header handler and points to a data buffer in local space. A reverse transfer
   * then takes place (the buffer is sent from the receiver back to the sender,
   * and deposited in one of the buffers provided as part of the original call
   * (the "data" parameter).
   *
   * \param[in]  dispatch     registered dispatch id to use
   * \param[in]  headers      array of metadata to send to destination
   * \param[in]  headerlen    length of every header in headers array
   * \param[in]  rcvbuf       target buffer of the gather operation (size of geometry)
   * \param[in]  rtype        data layout of the incoming gather
   * \param[in]  rtypecount   replication count of the incoming gather
   * \param[in]  cb_info      data done callback to call on completion
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                      dispatch;
    void                      * headers;
    size_t                      headerlen;
    void                      * rcvbuf;
    xmi_type_t                * rtype;
    size_t                      rtypecount;
  } xmi_amgather_t;
  /**
   * \brief The active message callback function, delivered to the user
   * \param[in]   root       system defined metadata:  root initiating the gather
   * \param[in]   comm       system defined metadata:  geometry id of the gather
   * \param[in]   sndlen     system defined metadata:  total number of bytes of the send
   * \param[in]   user_header user defined metadata:  active message header
   * \param[in]   headerlen  length of the user defined header (may be 0 bytes)
   * \param[out]  sbuf       source buffer for the incoming collective
   * \param[out]  stype      data layout of the send buffer
   * \param[out]  stypecount replication count of the send buffer
   * \param[out]  cb_info    data done callback to call on completion
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef void (*xmi_dispatch_amgather_fn) (size_t               root,
                                            xmi_geometry_t       geometry_id,
                                            const unsigned       sndlen,
                                            void               * user_header,
                                            const size_t         headerlen,
                                            void              ** sndbuf,
                                            xmi_type_t         * stype,
                                            size_t             * stypecount,
                                            xmi_event_function * const cb_info);

  /**
   * \brief Create and post a non-blocking active message reduce operation.
   * The Active Message reduce operation ...
   *
   * This is fairly straightforward given how amgather works. Instead of
   * collecting the data without processing, all buffers are reduced using the
   * operation and data type provided by the sender. The final reduced data is
   * deposited in the original buffer provided by the initiator. On the receive
   * side the algorithm has the right to change the buffers provided by the header
   * handler (this may avoid having the implementor allocate more memory for
   * internal buffering)
   *
   * \param[in]  dispatch     registered dispatch id to use
   * \param[in]  geometry     Geometry to use for this collective operation.
   *                          \c NULL indicates the global geometry.
   * \param[in]  headers      metadata to send to destinations in the header
   * \param[in]  rcvbuf       target buffer of the reduce operation (size of geometry)
   * \param[in]  rtype        data layout of the incoming reduce
   * \param[in]  rtypecount   replication count of the incoming reduce
   * \param[in]  dt           datatype of reduction operation
   * \param[in]  op           operation type
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef struct
  {
    size_t                      dispatch;
    void                      * user_header;
    size_t                      headerlen;
    void                      * rcvbuf;
    xmi_type_t                * rtype;
    size_t                      rtypecount;
    xmi_dt                      dt;
    xmi_op                      op;
  } xmi_amreduce_t;

  /**
   * \brief The active message callback function, delivered to the user
   *        Note that the user does no math in these routines, just provides the buffer.
   *        The system provided metadata is information that the underlying messaging stack
   *        must transmit anyways, so it is delivered to the user for extra information about
   *        the incoming message
   * \param[in]   root       system defined metadata:  root initiating the reduce
   * \param[in]   comm       system defined metadata:  geometry id of the reduce
   * \param[in]   dt         system defined metadata:  datatype of reduction operation
   * \param[in]   op         system defined metadata:  operation type
   * \param[in]   sndlen     system defined metadata:  total number of bytes of the send
   * \param[in]   user_header user defined metadata:  active message header
   * \param[in]   headerlen  length of the user defined header (may be 0 bytes)
   * \param[out]  sbuf       source buffer for the incoming collective
   * \param[out]  stype      data layout of the send buffer
   * \param[out]  stypecount replication count of the send buffer
   * \param[out]  cb_info    data done callback to call on completion
   *
   * \retval     0            Success
   *
   * \todo doxygen
   */
  typedef void (*xmi_dispatch_amreduce_fn) (size_t               root,
                                            xmi_geometry_t       geometry_id,
                                            const unsigned       sndlen,
                                            xmi_dt               dt,
                                            xmi_op               op,
                                            void               * user_header,
                                            const size_t         headerlen,
                                            void              ** sndbuf,
                                            xmi_type_t         * stype,
                                            size_t             * stypecount,
                                            xmi_event_function * const cb_info);


  typedef union
  {
    xmi_allreduce_t        xfer_allreduce;
    xmi_broadcast_t        xfer_broadcast;
    xmi_reduce_t           xfer_reduce;
    xmi_allgather_t        xfer_allgather;
    xmi_allgatherv_t       xfer_allgatherv;
    xmi_allgatherv_int_t   xfer_allgatherv_int;
    xmi_scatter_t          xfer_scatter;
    xmi_scatterv_t         xfer_scatterv;
    xmi_scatterv_int_t     xfer_scatterv_int;
    xmi_scatter_t          xfer_gather;
    xmi_scatter_t          xfer_gatherv;
    xmi_scatterv_t         xfer_gatherv_int;
    xmi_alltoall_t         xfer_alltoall;
    xmi_alltoallv_t        xfer_alltoallv;
    xmi_alltoallv_int_t    xfer_alltoallv_int;
    xmi_ambroadcast_t      xfer_ambroadcast;
    xmi_amscatter_t        xfer_amscatter;
    xmi_amgather_t         xfer_amgather;
    xmi_amreduce_t         xfer_amreduce;
    xmi_scan_t             xfer_scan;
    xmi_barrier_t          xfer_barrier;
    } xmi_collective_t;

  typedef struct
  {
    xmi_event_function       cb_done;
    void                   * cookie;
    xmi_algorithm_t          algorithm;
    xmi_collective_t         cmd;
  } xmi_xfer_t;

  xmi_result_t XMI_Collective (xmi_context_t context, xmi_xfer_t *cmd);

#define XMI_BYTE NULL

  /**
   * \brief Create a new type for noncontiguous transfers
   *
   * \todo provide example code
   *
   * \param[out] type Type identifier to be created
   */
  xmi_result_t XMI_Type_create (xmi_type_t * type);

  /**
   * \brief Append a simple contiguous buffer to an existing type identifier
   *
   * \todo doxygen for offset parameter
   * \todo provide example code
   *
   * \param[in,out] type   Type identifier to be modified
   * \param[in]     bytes  Number of contiguous bytes to append
   * \param[in]     offset Offset from the end of the type to place the buffer
   * \param[in]     count  Number of buffers
   * \param[in]     stride Data stride
   */
  xmi_result_t XMI_Type_add_simple (xmi_type_t type,
                                    size_t     bytes,
                                    size_t     offset,
                                    size_t     count,
                                    size_t     stride);

  /**
   * \brief Append a typed buffer to an existing type identifier
   *
   * \todo doxygen for offset parameter
   * \todo provide example code
   *
   * \warning It is considered \b illegal to append an imcomplete type to
   *          another type.
   *
   * \param[in,out] type    Type identifier to be modified
   * \param[in]     subtype Subtype to append
   * \param[in]     offset  Offset from the end of the type to place the buffer
   * \param[in]     count   Number of buffers
   * \param[in]     stride  Data stride
   */
  xmi_result_t XMI_Type_add_typed (xmi_type_t type,
                                   xmi_type_t subtype,
                                   size_t     offset,
                                   size_t     count,
                                   size_t     stride);

  /**
   * \brief Complete the type identifier
   *
   * \warning It is considered \b illegal to modify a type identifier after it
   *          has been completed.
   *
   * \param[in] type Type identifier to be completed
   */
  xmi_result_t XMI_Type_complete (xmi_type_t type);

  /**
   * \brief Get the byte size of a completed type
   *
   * \param[in] type Type identifier to get size from
   */
  xmi_result_t XMI_Type_sizeof (xmi_type_t type);

  /**
   * \brief Destroy the type
   *
   * Q. What if some in-flight messages are still using it?  What if some
   * other types have references to it?
   *
   * A. Maintain an internal reference count and release internal type
   * resources when the count hits zero.
   *
   * \param[in] type Type identifier to be destroyed
   */
  xmi_result_t XMI_Type_destroy (xmi_type_t type);

  /**
   * \brief Pack data from a non-contiguous buffer to a contiguous buffer
   *
   * \param[in] src_type   source data type
   * \param[in] src_offset starting offset of source data type
   * \param[in] src_addr   starting address of source buffer
   * \param[in] dst_addr   starting address of destination buffer
   * \param[in] dst_size   destination buffer size
   */
  xmi_result_t XMI_Type_pack_data (xmi_type_t src_type,
                                   size_t     src_offset,
                                   void     * src_addr,
                                   void     * dst_addr,
                                   size_t     dst_size);

  /**
   * \brief Unpack data from a contiguous buffer to a non-contiguous buffer
   *
   * \param[in] dst_type   destination data type
   * \param[in] dst_offset starting offset of destination data type
   * \param[in] dst_addr   starting address of destination buffer
   * \param[in] src_addr   starting address of source buffer
   * \param[in] src_size   source buffer size
   */
  xmi_result_t XMI_Type_unpack_data (xmi_type_t dst_type,
                                     size_t     dst_offset,
                                     void     * dst_addr,
                                     void     * src_addr,
                                     size_t     src_size);
  /** \} */ /* end of "datatype" group */

#include "xmi_ext.h"


  typedef union
  {
    xmi_dispatch_p2p_fn         p2p;
    xmi_dispatch_ambroadcast_fn ambroadcast;
    xmi_dispatch_amscatter_fn   amscatter;
    xmi_dispatch_amreduce_fn    amreduce;
    XMI_DISPATCH_EXTEND         /** Extensions to this structure included from xm_ext.h */
  } xmi_dispatch_callback_fn;

  /*****************************************************************************/
  /**
   * \defgroup dispatch xmi dispatch interface
   *
   * Some brief documentation on dispatch stuff ...
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief XMI type of dispatch
   */
  typedef enum
  {
    XMI_P2P_SEND,               /**< Point-to-point send         */
    XMI_DISPATCH_TYPE_EXTEND    /** Extensions to this structure included from xm_ext.h */
  } xmi_dispatch_type_t;

  /**
   * \brief Hints for dispatch
   *
   */
  typedef struct
  {
    xmi_dispatch_type_t    type;      /**< Type of dispatch reqistered    */
    union{
      xmi_send_hint_t      send;
      XMI_HINT_EXTEND                 /** Extensions to this structure included from xm_ext.h */
    }                      hint;      /**< Type-specific hints            */
    void*                  config;    /**< Type-specific additional config*/
  } xmi_dispatch_hint_t;

  /**
   * \brief Initialize the dispatch functions for a dispatch id.
   *
   * This is a local, non-collective operation. There is no communication
   * between tasks.
   *
   * \note The maximum allowed dispatch id attribute, \c XMI_DISPATCH_ID_MAX,
   *       can be queried with the configuration interface
   *
   * \see XMI_Configuration_query
   *
   * \param[in] context    XMI communication context
   * \param[in] dispatch   Dispatch identifier to initialize
   * \param[in] fn         Dispatch receive function
   * \param[in] cookie     Dispatch function cookie
   * \param[in] options    Dispatch registration assertions
   *
   */
  //#ifdef __xmi_target_mpi__
  xmi_result_t XMI_Dispatch_set_new(xmi_context_t              context,
                                 size_t                     dispatch,
                                 xmi_dispatch_callback_fn   fn,
                                 void                     * cookie,
                                 xmi_dispatch_hint_t        options);
  //#endif
  xmi_result_t XMI_Dispatch_set (xmi_context_t              context,
                                 size_t                     dispatch,
                                 xmi_dispatch_callback_fn   fn,
                                 void                     * cookie,
                                 xmi_send_hint_t            options);

  /**
   * \brief Initialize the dispatch functions for a dispatch id.
   *
   * This is a local, non-collective operation. There is no communication
   * between tasks.
   *
   * \param[in] context    XMI communication context
   * \param[in] algorithm  The AM collective to set the dispatch
   * \param[in] dispatch   Dispatch identifier to initialize
   * \param[in] fn         Dispatch receive function
   * \param[in] cookie     Dispatch function cookie
   * \param[in] options    Dispatch registration assertions
   *
   */
  xmi_result_t XMI_AMCollective_dispatch_set(xmi_context_t              context,
                                             xmi_algorithm_t            algorithm,
                                             size_t                     dispatch,
                                             xmi_dispatch_callback_fn   fn,
                                             void                     * cookie,
                                             xmi_collective_hint_t      options);
  /** \} */ /* end of "dispatch" group */

  /*****************************************************************************/
  /**
   * \defgroup configuration xmi configuration interface
   *
   * Some brief documentation on configuration stuff ...
   * \{
   */
  /*****************************************************************************/

  typedef char* xmi_user_key_t;   /**< ??? */
  typedef char* xmi_user_value_t; /**< ??? */
  typedef struct
  {
    xmi_user_key_t    key;   /**< The configuration key   */
    xmi_user_value_t  value; /**< The configuration value */
  } xmi_user_config_t;

  /**
   * This enum contains ALL possible attributes for all hardware
   */
  typedef enum {
    /* Attribute            Query / Update                                 */
    XMI_TASK_ID,            /**< Q : size_t : ID of this task (AKA "rank") */
    XMI_NUM_TASKS,          /**< Q : size_t : Total number of tasks        */
    XMI_NUM_CONTEXTS,       /**< Q : size_t : The maximum number of contexts allowed on this process */
    XMI_CONST_CONTEXTS,     /**< Q : size_t : All processes will return the same XMI_NUM_CONTEXTS */
    XMI_CLOCK_MHZ,          /**< Q : size_t : Frequency of the CORE clock, in units of 10^6/seconds.  This can be used to approximate the performance of the current task. */
    XMI_WTIMEBASE_MHZ,      /**< Q : size_t : Frequency of the WTIMEBASE clock, in units of 10^6/seconds.  This can be used to convert from XMI_Wtimebase to XMI_Timer manually. */
    XMI_WTICK,              /**< Q : double : This has the same definition as MPI_Wtick(). */
    XMI_MEM_SIZE,           /**< Q : size_t : Size of the core main memory, in units of 1024^2 Bytes    */
    XMI_SEND_IMMEDIATE_MAX, /**< Q : size_t : Maximum number of bytes that can be transfered with the XMI_Send_immediate() function. */
    XMI_RECV_IMMEDIATE_MAX, /**< Q : size_t : Maximum number of bytes that can be received, and provided to the application, in a dispatch function. */
    XMI_PROCESSOR_NAME,     /**< Q : char[] : A unique name string for the calling process, and should be suitable for use by
                                              MPI_Get_processor_name(). The storage should *not* be freed by the caller. */
    XMI_DISPATCH_ID_MAX,    /**< Q : size_t : Maximum allowed dispatch id, see XMI_Dispatch_set() */
  } xmi_attribute_name_t;

  typedef union
  {
    size_t      intval;
    double      doubleval;
    const char* chararray;
  } xmi_attribute_value_t;

#define XMI_EXT_ATTR 1000 /**< starting value for extended attributes */

  /**
   * \brief General purpose configuration structure.
   */
  typedef struct
  {
    xmi_attribute_name_t  name;  /**< Attribute type */
    xmi_attribute_value_t value; /**< Attribute value */
  } xmi_configuration_t;


  /**
   * \brief Query the value of an attribute
   *
   * \param [in]     client        The XMI client
   * \param [in,out] configuration  The configuration attribute of interest
   *
   * \note
   * \returns
   *   XMI_SUCCESS
   *   XMI_ERR_CONTEXT
   *   XMI_ERR_ATTRIBUTE
   *   XMI_ERR_VALUE
   */
  xmi_result_t XMI_Configuration_query (xmi_client_t client,
                                        xmi_configuration_t * configuration);

  /**
   * \brief Update the value of an attribute
   *
   * \param [in] client       The XMI client
   * \param [in] configuration The configuration attribute to update
   *
   * \note
   * \returns
   *   XMI_SUCCESS
   *   XMI_ERR_CONTEXT
   *   XMI_ERR_ATTRIBUTE
   *   XMI_ERR_VALUE
   */
  xmi_result_t XMI_Configuration_update (xmi_client_t client,
                                         xmi_configuration_t * configuration);

  /**
   * \brief Provides the detailed description of the most recent xmi result.
   *
   * The "most recent xmi result" is specific to each thread.
   *
   * \note  XMI implementations may provide translated (i18n) text.
   *
   * \param[in] string Character array to write the descriptive text
   * \param[in] length Length of the character array
   *
   * \return Number of characters written into the array
   */
  size_t XMI_Error_text (char * string, size_t length);


  /** \} */ /* end of "configuration" group */


  /*****************************************************************************/
  /**
   * \defgroup Time Timer functions required by MPI
   *
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief  Returns an elapsed time on the calling processor.
   * \note   This has the same definition as MPI_Wtime
   * \return Time in seconds since an arbitrary time in the past.
   */
  double XMI_Wtime();

  /**
   * \brief  Returns the number of "cycles" elapsed on the calling processor.
   * \return Number of "cycles" since an arbitrary time in the past.
   *
   * "Cycles" could be any quickly and continuously increasing counter
   * if true cycles are unavailable.
   */
  unsigned long long XMI_Wtimebase();

  /** \} */ /* end of "Time" group */


  /*****************************************************************************/
  /**
   * \defgroup contexts_and_endpoints multi-context messaging interface
   *
   * Some brief documentation on context stuff ...
   * \{
   */
  /*****************************************************************************/

  /**
   * \brief Initialize the XMI runtime for a client program
   *
   * An XMI client represents a collection of resources to enable network
   * communications. Each XMI client that is initialized is unque and does not
   * directly communicate with other clients. This allows middleware to be
   * developed independently and each middleware can be used concurrently by an
   * application. Resources are allocated and assigned at client creation time.
   *
   * An XMI client \em program is any software that invokes an XMI function.
   * This includes applications, libraries, and other middleware. Some example
   * client names may include: "MPI", "UPC", "OpenSHMEM", and "ARMCI"
   *
   * A communication context must be created before any data transfer functions
   * may be invoked.
   *
   * \see XMI_Context_createv
   *
   * \param[in]  name   XMI client unique name
   * \param[out] client Opaque client object
   */
  xmi_result_t XMI_Client_initialize (const char   * name,
                                      xmi_client_t * client);

  /**
   * \brief Finalize the XMI runtime for a client program
   *
   * \warning It is \b illegal to invoke any XMI functions using the client
   *          handle from any thread after the finalize function.
   *
   * \param[in] client XMI client handle
   */
  xmi_result_t XMI_Client_finalize (xmi_client_t client);

  /**
   * \brief Construct an endpoint to address communication destinations
   *
   * Endpoints are opaque objects that are used to address a destination
   * in a client and are constructed from a client, task, and context offset.
   * - The client is required to disambiguate the task and context offset
   *   identifiers, as these identifiers may be the same for multiple clients
   * - The task is required to construct an endpoint to address the specific
   *   process that contains the destination context
   * - The context offset is required to identify the specific context on the
   *   destination task. Recall that a context identifies a specific threading
   *   point on a task. The context offset identifies which threading point
   *   will process the communication operation.
   *
   * Point-to-point communication operations, such as send, put, and get, will
   * address a destniation with the opaque endpoint object. Collective
   * communication operations are addressed by an opaque geometry object.
   *
   * The application may choose to write an endpoint table in shared memory to
   * save storage in an environment where multiple tasks of a client have
   * access to the same shared memory area  It is the responsibility of the
   * application to allocate this shared memory area and coordinate the
   * initialization and access of any shared data structures. This includes
   * any opaque endpoint objects which may be created by one task and read by
   * another task.
   *
   * \internal The endpoint opaque object should not contain any pointers to
   *           the local address space of a particular process as doing so will
   *           prevent the application from placing an array of endpoints in a
   *           shared memory area to be used, read-only, by all tasks with
   *           access to the shared memory area.
   *
   * \note This function may be replaced with a generated macro specific to the
   *       install platform if needed for performance reasons.
   *
   * \param[in] client Opaque destination client object
   * \param[in] task   Opaque destination task object
   * \param[in] offset Destination context offset
   *
   * \returns Opaque endpoint object
   */
  xmi_endpoint_t XMI_Client_endpoint (xmi_client_t client,
                                      xmi_task_t   task,
                                      size_t       offset);

  /**
   * \example endpoint_table.c
   * This example demonstrates how to construct an endpoint table containing
   * all endpoints in the system. The endpoint table can then be used, in
   * concert with a wrapper function, as a way to address all endpoints as
   * monotonically increasing integers.
   *
   * \todo Move the doxygen comment block somewhere else
   */

  /**
   * \brief Construct an endpoint for each context in a task
   *
   * This function may be used to initialize an array of all endpoints for a
   * client by looping over all tasks.
   *
   * \param[in]     client    Opaque destination client object
   * \param[in]     task      Opaque destination task object
   * \param[in,out] endpoints Array of opaque endpoint objects to initialize
   * \param[in,out] count     Length of the endpoint array available/initialized
   *
   * \retval XMI_INVAL The number endpoints on the task is larger than the
   *                   size of endpoint array
   */
  xmi_result_t XMI_Client_endpointv (xmi_client_t     client,
                                     xmi_task_t       task,
                                     xmi_endpoint_t * endpoints,
                                     size_t         * count);

  /**
   * \brief Retrieve the client, task, and context offset associated with an endpoint
   *
   * The endpoint must have been previously initialized with the
   * XMI_Client_endpoint or XMI_Client_endpointv function.
   *
   * \note This function may be replaced with a generated macro specific to the
   *       install platform if needed for performance reasons.
   *
   * \param[in]  endpoint Opaque endpoint object
   * \param[out] task     Opaque destination task object
   * \param[out] offset   Destination context offset
   */
  void XMI_Client_endpoint_info (xmi_endpoint_t   endpoint,
                                 xmi_task_t     * task,
                                 size_t         * offset);



  /**
   * \brief Create new independent communication contexts for a client
   *
   * Contexts are local "threading points" that an application may use to
   * optimize concurrent communcation operations. A context handle is an
   * opaque object type that the application must not directly read or write
   * the value of the object.
   *
   * Communication contexts have these features:
   * - Each context is a partition of the local resources assigned to the
   *   client object for each task
   * - Every context within a client has equivalent functionality and
   *   semantics
   * - Communcation operations initiated by the local task will use the
   *   opaque context object to identify the specific threading point that
   *   will be used to issue the communication independent of communication
   *   occuring in other contexts
   * - All local event callbacks(s) associated with a communication operation
   *   will be invoked by the thread which advances the context that was used
   *   to initiate the operation
   * - A context is a local object and is not used to directly address a
   *   communication destination
   * - Progress is driven independently among contexts
   * - Progress may be driven concurrently among contexts, by using multiple
   *   threads, as desired by the application
   * - <b>All contexts created by a client must be advanced by the application
   *   to prevent deadlocks</b>
   *
   * \note The progress rule may be relaxed in future versions of the interface
   *
   * \par Thread considerations
   *       Applications map, or "apply", threading resources to contexts.
   *       Operations on contexts are critical sections and not thread-safe.
   *       The application must ensure that critical sections are protected
   *       from re-entrant use. XMI provides mechanisms for controlling access
   *       to critical sections
   *
   * The context configuration attributes may include:
   * - Context optimizations, such as shared memory, collective acceleration, etc
   *
   * Context creation is a local operation and does not involve communication or
   * syncronization with other tasks.
   *
   * \param[in]  client        Client handle
   * \param[in]  configuration List of configurable attributes and values
   * \param[in]  count         Number of configurations, may be zero
   * \param[out] context       Array of communication contexts to initialize
   * \param[in]  ncontexts     num contexts requested (in), created (out)
   */
  xmi_result_t XMI_Context_createv (xmi_client_t          client,
                                    xmi_configuration_t   configuration[],
                                    size_t                count,
                                    xmi_context_t       * context,
                                    size_t                ncontexts);


  /**
   * \brief Destroy an independent communication context
   *
   * \todo Is is appropriate for the interface to allow contexts to be
   *       individually destroyed when all contexts were created in a
   *       single function?
   *
   * \warning It is \b illegal to invoke any XMI functions using the
   *          communication context from any thread after the context is
   *          destroyed.
   *
   * \param[in] context XMI communication context
   */
  xmi_result_t XMI_Context_destroy (xmi_context_t context);

  /**
   * \brief Post work to a context, thread-safe
   *
   * It is \b not required that the target context is locked, or otherwise
   * reserved, by an external atomic operation to ensure thread safety. The XMI
   * runtime will internally perform any neccessary atomic operations in order
   * to post the work to the context.
   *
   * The callback function will be invoked in the thread that advances the
   * \em work context. There is no implicit completion notification provided
   * to the \em posting thread when the thread advancing the \em work context
   * returns from the callback event function.  If the posting thread desires
   * a completion notification it must explicitly program such notifications,
   * via the XMI_Context_post() interface, from the target thread back to the
   * origin thread
   *
   * \todo Needs some opaque storage to enqueue on to the work queue. This is
   *       neccesary to improve the performance for the MMPS benchmark. In
   *       other words, latency may degrade if the internal implementation
   *       must allocate memory.
   *
   * \param[in] context XMI communication context
   * \param[in] work_fn Event callback function to post to the context
   * \param[in] cookie  Opaque data pointer to pass to the event function
   */
  xmi_result_t XMI_Context_post (xmi_context_t        context,
                                 xmi_work_t         * work,
                                 xmi_work_function    fn,
                                 void               * cookie);


  /**
   * \brief Advance the progress engine for a single communication context
   *
   * May complete zero, one, or more outbound transfers. May invoke dispatch
   * handlers for incoming transfers. May invoke work event callbacks previously
   * posted to the communication context.
   *
   * This polling advance function will return after the first poll iteration
   * that results in a processed event or if, no events are processed, after
   * polling for the maximum number of iterations.
   *
   * \warning This function is \b not \b threadsafe and the application must
   *          ensure that only one thread advances a context at any time.
   *
   * \see XMI_Context_lock
   * \see XMI_Context_trylock
   *
   * \todo Define return code, event bitmask ?
   *
   * \param[in] context XMI communication context
   * \param[in] maximum Maximum number of internal poll iterations
   */
  xmi_result_t XMI_Context_advance (xmi_context_t context, size_t maximum);

  /**
   * \brief Advance the progress engine for multiple communication contexts
   *
   * May complete zero, one, or more outbound transfers. May invoke dispatch
   * handlers for incoming transfers. May invoke work event callbacks previously
   * posted to a communication context.
   *
   * This polling advance function will return after the first poll iteration
   * that results in a processed event on any context, or if, no events are
   * processed, after polling for the maximum number of iterations.
   *
   * \warning This function is \b not \b threadsafe and the application must
   *          ensure that only one thread advances the contexts at any time.
   *
   * \note It is possible to define a set of communication contexts that are
   *       always advanced together by any xmi client thread.  It is the
   *       responsibility of the xmi client to atomically lock the context set,
   *       perhaps by using the XMI_Context_lock() function on a designated
   *       \em leader context, and to manage the xmi client threads to ensure
   *       that only one thread ever advances the set of contexts.
   *
   * \todo Define return code, event bitmask ?
   * \todo Rename function to something better
   *
   * \see XMI_Context_lock
   * \see XMI_Context_trylock
   *
   * \param[in] context Array of XMI communication contexts
   * \param[in] count   Number of communication contexts
   * \param[in] maximum Maximum number of internal poll iterations on each context
   */
  xmi_result_t XMI_Context_multiadvance (xmi_context_t context[],
                                         size_t        count,
                                         size_t        maximum);

  /**
   * \brief Acquire an atomic lock on a communication context
   *
   * \warning This function will block until the lock is aquired.
   *
   * \param[in] context XMI communication context
   */
  xmi_result_t XMI_Context_lock (xmi_context_t context);

  /**
   * \brief Attempt to acquire an atomic lock on a communication context
   *
   * May return \c EAGAIN if the lock was not acquired.
   *
   * \param[in] context XMI communication context
   */
  xmi_result_t XMI_Context_trylock (xmi_context_t context);

  /**
   * \brief Release an atomic lock on a communication context
   *
   * \param[in] context XMI communication context
   */
  xmi_result_t XMI_Context_unlock (xmi_context_t context);

  /** \} */ /* end of "context" group */

#ifdef __cplusplus
};
#endif

#endif /* __xmi__h__ */

///
/// \file test/internals/multisend/multicombine.cc
/// \brief ???
///

#include <stdio.h>
#include <pami.h>

#include "test/internals/multisend/multicombine.h"
#include "components/devices/workqueue/WQRingReduceMsg.h"
#include "components/devices/workqueue/LocalReduceWQMessage.h"
#include "components/devices/workqueue/LocalAllreduceWQMessage.h"

#include "components/devices/shmemcoll/ShmemCollDevice.h"
#include "components/devices/shmemcoll/ShmemCollDesc.h"
#include "components/devices/shmemcoll/ShmemMcombModelWorld.h"
#include "components/atomic/bgq/L2Counter.h"

//#include "quad_sum.h"
//#include "16way_sum.h"
//#include "8way_sum.h"

#ifndef TEST_BUF_SIZE
//#define TEST_BUF_SIZE	128
//#define TEST_BUF_SIZE	4104
//#define TEST_BUF_SIZE	4096
#define TEST_BUF_SIZE	65536
//#define TEST_BUF_SIZE	1024
#endif // TEST_BUF_SIZE
//#define ITER	16
#define ITER	2

//typedef PAMI::Device::Shmem::ShmemCollDesc <PAMI::Atomic::GccBuiltin> ShmemCollDesc;
typedef PAMI::Device::Shmem::ShmemCollDesc <PAMI::Counter::BGQ::L2NodeCounter> ShmemCollDesc;
typedef PAMI::Device::ShmemCollDevice <ShmemCollDesc> ShmemCollDevice;
typedef PAMI::Device::Shmem::ShmemMcombModelWorld <ShmemCollDevice, ShmemCollDesc> ShmemMcombModel;

#define LOCAL_REDUCE_NAME	"PAMI::Device::ShmemMcombModel"
#define LOCAL_REDUCE_MODEL ShmemMcombModel	
#define LOCAL_REDUCE_DEVICE ShmemCollDevice

//#define SUM_PROCESS_SINGLE

#define MEM_ALLOC_ALIGNED(x) 	{  myMemory = malloc ( TEST_BUF_SIZE + my_alignment );\
									if ( !myMemory ) printf("malloc failed\n");\
									x  = (double*)( ((uint64_t)myMemory + my_alignment)  & ~(my_alignment-1) );\
								}		

PAMI::Topology otopo;

int main(int argc, char ** argv) {
        pami_context_t context;
        size_t task_id;
        size_t num_tasks;


#ifdef SUM_PROCESS_SINGLE

		double* src0, *src1,* src2, *src3, *src4, *src5, *src6, *src7, *src8, *src9, *src10, *src11, *src12, *src13, *src14, *src15, *dst;
		uint64_t my_alignment;
        my_alignment = 128;
		void* myMemory;
		
		MEM_ALLOC_ALIGNED(src0);
		MEM_ALLOC_ALIGNED(src1);
		MEM_ALLOC_ALIGNED(src2);
		MEM_ALLOC_ALIGNED(src3);
		MEM_ALLOC_ALIGNED(src4);
		MEM_ALLOC_ALIGNED(src5);
		MEM_ALLOC_ALIGNED(src6);
		MEM_ALLOC_ALIGNED(src7);
		MEM_ALLOC_ALIGNED(src8);
		MEM_ALLOC_ALIGNED(src9);
		MEM_ALLOC_ALIGNED(src10);
		MEM_ALLOC_ALIGNED(src11);
		MEM_ALLOC_ALIGNED(src12);
		MEM_ALLOC_ALIGNED(src13);
		MEM_ALLOC_ALIGNED(src14);
		MEM_ALLOC_ALIGNED(src15);
		MEM_ALLOC_ALIGNED(dst);

		for (unsigned i =0; i < TEST_BUF_SIZE/sizeof(double); i++)
		{
			src0[i] = src1[i] = src2[i] = src3[i] =src4[i] = src5[i] = src6[i] =src7[i] =src8[i] =src9[i]= src10[i]=src11[i]=src12[i]=src13[i]=src14[i]=src15[i]=1.0;
		}

		/*quad_double_sum_16way_opt(dst, src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10, src11, src12, src13, src14, src15, TEST_BUF_SIZE/sizeof(double));
		 unsigned long long t1 = PAMI_Wtimebase();
		quad_double_sum_16way_opt(dst, src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10, src11, src12, src13, src14, src15, TEST_BUF_SIZE/sizeof(double));
		quad_double_sum_16way_opt(dst, src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10, src11, src12, src13, src14, src15, TEST_BUF_SIZE/sizeof(double));
		 unsigned long long t2 = PAMI_Wtimebase();
		fprintf(stderr,"cycles:%lld, bytes:%d\n", (t2-t1)/2, (int)(TEST_BUF_SIZE/sizeof(double)));
		return 0;*/
		quad_double_sum_8way(dst, src0, src1, src2, src3, src4, src5, src6, src7, TEST_BUF_SIZE/sizeof(double));
		 unsigned long long t1 = PAMI_Wtimebase();
		quad_double_sum_8way(dst, src0, src1, src2, src3, src4, src5, src6, src7, TEST_BUF_SIZE/sizeof(double));
		quad_double_sum_8way(dst, src0, src1, src2, src3, src4, src5, src6, src7, TEST_BUF_SIZE/sizeof(double));
		 unsigned long long t2 = PAMI_Wtimebase();
		fprintf(stderr,"cycles:%lld, bytes:%d\n", (t2-t1)/2, (int)(TEST_BUF_SIZE/sizeof(double)));
		return 0;
#endif



#if 0
        pami_client_t client;
        pami_result_t status = PAMI_ERROR;
        status = PAMI_Client_create("multicombine test", &client, NULL, 0);
        if (status != PAMI_SUCCESS) {
                fprintf (stderr, "Error. Unable to initialize pami client. result = %d\n", status);
                return 1;
        }

        { size_t _n = 1; status = PAMI_Context_createv(client, NULL, 0, &context, _n); }
        if (status != PAMI_SUCCESS) {
                fprintf (stderr, "Error. Unable to create pami context. result = %d\n", status);
                return 1;
        }

        pami_configuration_t configuration;

        configuration.name = PAMI_CLIENT_TASK_ID;
        status = PAMI_Client_query(client, &configuration, 1);
        if (status != PAMI_SUCCESS) {
                fprintf (stderr, "Error. Unable query configuration (%d). result = %d\n", configuration.name, status);
                return 1;
        }
        task_id = configuration.value.intval;
        //fprintf(stderr, "My task id = %zu\n", task_id);

        configuration.name = PAMI_CLIENT_NUM_TASKS;
        status = PAMI_Client_query(client, &configuration, 1);
        if (status != PAMI_SUCCESS) {
                fprintf (stderr, "Error. Unable query configuration (%d). result = %d\n", configuration.name, status);
                return 1;
        }
        num_tasks = configuration.value.intval;
#else
        task_id = __global.mapping.task();
        num_tasks = __global.mapping.size();
        context = (pami_context_t)1; // context must not be NULL
        PAMI::Memory::MemoryManager mm;
        initializeMemoryManager("multicombine test", 8192*1024, mm);
#endif
        if (task_id == 0) fprintf(stderr, "Number of tasks = %zu\n", num_tasks);
        if (__global.topology_local.size() < 2) {
                fprintf(stderr, "requires at least 2 ranks to be local\n");
                exit(1);
        }

// END standard setup
// ------------------------------------------------------------------------

        // Register some multicombines, C++ style

        //pami_result_t rc;
        size_t root = __global.topology_local.index2Rank(0);
        if (task_id == root) fprintf(stderr, "Number of local tasks = %zu\n", __global.topology_local.size());

        new (&otopo) PAMI::Topology(root);

        pami_multicombine_t mcomb;

        // simple allreduce on the local ranks...
        mcomb.client = 0;
        mcomb.context = 0;
        mcomb.roles = (unsigned)-1;
        mcomb.data_participants = (pami_topology_t *)&__global.topology_local;
        mcomb.results_participants = (pami_topology_t *)&otopo;
        mcomb.optor = PAMI_SUM;
        mcomb.dtype = PAMI_DOUBLE;
        mcomb.count = TEST_BUF_SIZE / sizeof(double);

        const char *test = LOCAL_REDUCE_NAME;
        if (task_id == root) fprintf(stderr, "=== Testing %s...\n", test);
        PAMI::Test::Multisend::Multicombine<LOCAL_REDUCE_MODEL,LOCAL_REDUCE_DEVICE,TEST_BUF_SIZE> test1(test, mm);

		unsigned long long diff = 0, sum=0;
		for (unsigned iter =0 ; iter < ITER+2; iter++)
        {

        diff = test1.perform_test(task_id, num_tasks, context, &mcomb);

        /*if (rc != PAMI_SUCCESS) {
                fprintf(stderr, "Failed %s test\n", test);
                exit(1);
        }*/
		if (iter > 1) sum+=diff;
        //fprintf(stderr, "PASS %s\n", test);
		}

		if (task_id == root) fprintf(stderr,"cycles:%lld bytes:%d\n", sum/ITER, TEST_BUF_SIZE); 
        return 0;

#if 0
        status = PAMI_Client_destroy(&client);
        if (status != PAMI_SUCCESS) {
                fprintf(stderr, "Error. Unable to finalize pami client. result = %d\n", status);
                return 1;
        }
#endif

        return 0;
}
